<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>GRDF ‚Äì Mesures Terrain (SIG Pro) ‚Äì V2.1.6</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    :root{
      --bg:#0b1220;
      --panel: rgba(10, 14, 22, .78);
      --panel2: rgba(8, 10, 14, .70);
      --stroke: rgba(255,255,255,.12);
      --stroke2: rgba(255,255,255,.18);
      --text:#e9f1ff;
      --muted: rgba(233,241,255,.72);
      --accent:#3aa0ff;

      --frame-top: 72px;
      --frame-left: 12px;
      --frame-right: 12px;
      --frame-bottom: 18px;
      --frame-radius: 16px;

      /* UI fixed positions */
      --dock-bottom: 16px;
      --confirmpad-bottom: 92px; /* juste au-dessus du dock */
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 25% 10%, rgba(58,160,255,.18), transparent 60%),
                  radial-gradient(900px 600px at 90% 0%, rgba(46,211,168,.16), transparent 60%),
                  linear-gradient(180deg, #081020 0%, #070b12 100%);
      color: var(--text);
      font-family: Inter, Segoe UI, system-ui, -apple-system, Arial, sans-serif;
      overflow:hidden;
      touch-action:none;
    }

    .topbar{
      position:fixed;
      left:0; right:0; top:0;
      height:64px;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      z-index:100;
      pointer-events:none;
    }
    .topbar > *{ pointer-events:auto; }

    .glass{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius: 16px;
    }

    /* +++ Lisibilit√© renforc√©e pour certains blocs +++ */
    .glass.readable{
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.38));
      border-color: rgba(255,255,255,.14);
      box-shadow: 0 14px 36px rgba(0,0,0,.45);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      min-width: 210px;
    }
    .brand .logo{
      width:40px; height:40px;
      border-radius:14px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.2);
    }
    .brand .logo img{
      height:32px;
      width:auto;
      display:block;
    }
    .brand .title{
      display:flex;
      flex-direction:column;
      line-height:1.05;
    }
    .brand .title .t1{
      font-weight:900;
      letter-spacing:.4px;
      font-size:1.02rem;
    }
    .brand .title .t2{
      font-size:.80rem;
      color: var(--muted);
      font-weight:700;
    }

    .pager{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px;
      min-width: 320px;
      justify-content:center;
    }
    .pager .block{
      display:flex;
      align-items:center;
      gap:8px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding:8px;
    }
    .pager .label{
      min-width:96px;
      text-align:center;
      font-weight:800;
      color: rgba(233,241,255,.85);
      font-variant-numeric: tabular-nums;
    }
    .pager input{
      width:64px;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color: var(--text);
      font-weight:800;
      text-align:center;
      outline:none;
      font-variant-numeric: tabular-nums;
    }

    .btn{
      height:42px;
      padding:0 14px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      cursor:pointer;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn i{ opacity:.95; }
    .btn:hover:not(:disabled){ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.08); }
    .btn:active:not(:disabled){ transform: translateY(0px) scale(.99); }
    .btn:disabled{ opacity:.35; cursor:not-allowed; }

    .btn.icon{
      width:42px;
      justify-content:center;
      padding:0;
      border-radius: 14px;
    }
    .btn.danger{
      background: rgba(231,76,60,.14);
      border-color: rgba(231,76,60,.25);
      color: #ffd7d2;
    }
    .btn.danger:hover:not(:disabled){
      background: rgba(231,76,60,.22);
      border-color: rgba(231,76,60,.35);
    }

    .top-actions{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
    }

    #statusBubble{
      position:fixed;
      top:74px;
      left:50%;
      transform:translateX(-50%) translateY(-6px);
      padding:10px 18px;
      border-radius: 999px;
      background: rgba(0,0,0,.62);
      border:1px solid var(--stroke);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      z-index:120;
      font-weight:900;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    #statusBubble.visible{ opacity:1; transform:translateX(-50%) translateY(0); }
    #statusBubble.success{ border-color: rgba(46, 211, 168, .35); color:#bff7ea; }
    #statusBubble.warning{ border-color: rgba(241,196,15,.35); color:#fff2b8; }
    #statusBubble.error{ border-color: rgba(231,76,60,.35); color:#ffd7d2; }

    #appFrame{
      position:absolute;
      top:var(--frame-top);
      left:var(--frame-left);
      right:var(--frame-right);
      bottom:var(--frame-bottom);
      border-radius:var(--frame-radius);
      pointer-events:none;
      z-index:10;
      border:2px solid rgba(255,255,255,.14);
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,.35),
        0 18px 50px rgba(0,0,0,.35);
    }

    #canvas-wrapper{
      position:absolute;
      top:var(--frame-top);
      left:var(--frame-left);
      right:var(--frame-right);
      bottom:var(--frame-bottom);
      border-radius:var(--frame-radius);
      overflow:hidden;
      background: rgba(0,0,0,.18);
      z-index:1;
      overscroll-behavior:none;
    }

    /* Dock */
    .dock{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: var(--dock-bottom);
      z-index:120;
      padding:10px 12px;
      display:flex;
      align-items:center;
      gap:10px;
      pointer-events:auto;
    }
    .dock .divider{
      width:1px;
      height:28px;
      background: rgba(255,255,255,.14);
      margin:0 2px;
    }

    .btn-icon{
      width:52px;
      height:52px;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color: var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn-icon:hover:not(:disabled){
      transform: translateY(-1px);
      background: rgba(255,255,255,.08);
      border-color: var(--stroke2);
    }
    .btn-icon:active:not(:disabled){ transform: translateY(0) scale(.99); }
    .btn-icon:disabled{ opacity:.35; cursor:not-allowed; }
    .btn-icon.active{
      background: rgba(58,160,255,.18);
      border-color: rgba(58,160,255,.40);
      box-shadow: 0 0 0 4px rgba(58,160,255,.10);
    }
    .btn-undo{ color:#ffe28f; }
    .btn-delete{ color:#ffd7d2; }

    /* Color palette */
    #colorPicker{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: 92px;
      z-index:120;
      padding:10px 14px;
      display:flex;
      gap:12px;
      border-radius: 999px;
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
    }
    #colorPicker.show{ opacity:1; pointer-events:auto; }
    .dot{
      width:34px;
      height:34px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.22);
      cursor:pointer;
      transition: transform .12s ease, border-color .2s ease;
    }
    .dot:hover{ transform: scale(1.12); }
    .dot.sel{
      border-color: rgba(255,255,255,.92);
      box-shadow: 0 0 0 4px rgba(255,255,255,.10);
      transform: scale(1.06);
    }

    /* Plan minute panel */
    #minutePanel{
      position:absolute;
      left: calc(var(--frame-left) + 14px);
      top:  calc(var(--frame-top) + 14px);
      z-index:120;
      padding:12px;
      min-width: 250px;
      display:none;
    }
    #minutePanel.show{ display:block; }
    .mp-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:10px;
      font-weight:900;
    }
    .mp-title span{ color: rgba(233,241,255,.92); }
    .mp-grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:8px;
    }
    .mp-item{
      height:44px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      font-weight:900;
      user-select:none;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
    }
    .mp-item:hover{ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.06); }
    .mp-item.active{
      background: rgba(58,160,255,.18);
      border-color: rgba(58,160,255,.40);
      box-shadow: 0 0 0 4px rgba(58,160,255,.10);
    }
    .mp-hint{
      margin-top:10px;
      font-size:.82rem;
      color: rgba(233,241,255,.78);
      line-height:1.28rem;
    }

    /* Scale box */
    #scaleBox{
      position:fixed;
      right: 16px;
      top: 84px;
      z-index:130;
      padding:10px 12px;
      width: 170px;
    }
    #scaleBox .row1{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:1000;
      letter-spacing:.4px;
      color: rgba(233,241,255,.9);
      margin-bottom:8px;
    }
    #scaleBox .badge{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:900;
      border-radius: 999px;
      padding:8px 10px;
      border:1px solid rgba(241,196,15,.35);
      background: rgba(241,196,15,.10);
      color: #fff2b8;
      font-size:.86rem;
    }
    #scaleBox .badge.ok{
      border-color: rgba(46,211,168,.35);
      background: rgba(46,211,168,.10);
      color:#bff7ea;
    }

    /* Touch cursor */
    #touchCursor{
      position:fixed;
      left:0; top:0;
      width:54px; height:54px;
      border-radius: 50%;
      border: 3px solid rgba(58,160,255,.85);
      box-shadow: 0 0 0 6px rgba(58,160,255,.18);
      transform: translate(-9999px,-9999px);
      z-index:200;
      pointer-events:none;
      display:none;
      background: rgba(0,0,0,.05);
      backdrop-filter: blur(2px);
    }
    #touchCursor .dot{
      position:absolute;
      left:50%; top:50%;
      width:10px; height:10px;
      border-radius: 50%;
      background: rgba(255,255,255,.92);
      transform: translate(-50%,-50%);
      border: 1px solid rgba(0,0,0,.35);
    }

    /* Confirm pad FIXE au-dessus du dock */
    #confirmPad{
      position:fixed;
      left:50%;
      bottom: var(--confirmpad-bottom);
      transform: translateX(-50%);
      z-index:210;
      display:none;
      gap:10px;
      padding:10px;
      align-items:center;
      justify-content:center;
    }
    #confirmPad.show{ display:flex; }

    .cbtn{
      height:52px;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.32);
      color: var(--text);
      font-weight:1000;
      display:flex;
      align-items:center;
      gap:10px;
      padding:0 16px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
      white-space:nowrap;
    }
    .cbtn:hover:not(:disabled){ transform: translateY(-1px); background: rgba(255,255,255,.07); border-color: var(--stroke2); }
    .cbtn:disabled{ opacity:.45; cursor:not-allowed; }
    .cbtn.ok{
      background: rgba(46,211,168,.16);
      border-color: rgba(46,211,168,.30);
    }
    .cbtn.end{
      background: rgba(58,160,255,.16);
      border-color: rgba(58,160,255,.30);
    }
    .cbtn.cancel{
      background: rgba(231,76,60,.16);
      border-color: rgba(231,76,60,.30);
      padding:0 18px;
    }

    #versionLabel{
      position:fixed;
      right: 12px;
      bottom: 6px;
      z-index:140;
      font-size:.74rem;
      opacity:.35;
      font-weight:900;
      letter-spacing:.2px;
    }

    @media (max-width: 900px){
      :root{ --frame-top: 68px; --frame-left: 10px; --frame-right: 10px; --frame-bottom: 14px; }
      .brand{ min-width: 190px; }
      .pager{ min-width: 280px; }
      .btn-icon{ width:56px; height:56px; border-radius: 18px; }
      :root{ --confirmpad-bottom: 98px; }
    }
    @media (max-width: 650px){
      .pager{ display:none; }
      #scaleBox{ top: 76px; right: 12px; width: 165px; }
      .brand{ min-width: 150px; padding:10px; }
      .brand .title .t1{ font-size:.98rem; }
      .brand .title .t2{ font-size:.78rem; }
      :root{ --confirmpad-bottom: 102px; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="brand glass">
      <div class="logo" title="Logo">
        <img src="grdf-logo.png" alt="GRDF">
      </div>
      <div class="title">
        <div class="t1">GRDF ‚Äì Mesures Terrain</div>
        <div class="t2" id="subTitle">SIG Pro ‚Ä¢ V2.1.6</div>
      </div>
    </div>

    <div class="pager glass" title="Navigation PDF">
      <div class="block">
        <button id="btnPrevPage" class="btn icon" disabled title="Page pr√©c√©dente"><i class="fa-solid fa-chevron-left"></i></button>
        <div class="label" id="pageLabel">Page - / -</div>
        <button id="btnNextPage" class="btn icon" disabled title="Page suivante"><i class="fa-solid fa-chevron-right"></i></button>
      </div>
      <input id="pageJump" type="number" min="1" step="1" placeholder="N¬∞" disabled>
      <button id="btnGoPage" class="btn icon" disabled title="Aller"><i class="fa-solid fa-arrow-right-to-bracket"></i></button>
    </div>

    <div class="top-actions glass">
      <label for="fileInput" class="btn" title="Ouvrir un PDF">
        <i class="fa-solid fa-folder-open"></i><span>Ouvrir</span>
      </label>
      <input type="file" id="fileInput" accept=".pdf" style="display:none;">

      <button id="btnFullscreen" class="btn" title="Plein √©cran">
        <i class="fa-solid fa-expand"></i><span>Plein √©cran</span>
      </button>

      <button id="btnSave" class="btn" disabled title="Exporter PNG">
        <i class="fa-solid fa-floppy-disk"></i><span>PNG</span>
      </button>

      <button id="btnClear" class="btn danger" title="Tout effacer (page courante)">
        <i class="fa-solid fa-trash"></i><span>Effacer</span>
      </button>
    </div>
  </div>

  <div id="statusBubble" class="glass">Bienvenue</div>

  <!-- Scale box: lisible -->
  <div id="scaleBox" class="glass readable">
    <div class="row1">
      <span>√âCHELLE</span>
      <span style="opacity:.7"><i class="fa-solid fa-minus"></i></span>
    </div>
    <div id="scaleBadge" class="badge">
      <i class="fa-solid fa-triangle-exclamation"></i>
      <span id="scaleText">Non d√©tect√©e</span>
    </div>
  </div>

  <div id="minutePanel" class="glass">
    <div class="mp-title">
      <span><i class="fa-solid fa-file-pen"></i> Plan minute</span>
      <span style="opacity:.8; font-size:.82rem" id="minuteToolLabel">Outil : Cote</span>
    </div>

    <div class="mp-grid">
      <div class="mp-item active" data-tool="pm_cote" title="Tracer une cote">Cote</div>
      <div class="mp-item" data-tool="pm_pb" title="Prise de branchement">PB</div>
      <div class="mp-item" data-tool="pm_bouchon" title="Bouchon">B</div>
      <div class="mp-item" data-tool="pm_vanne" title="Vanne">V</div>
      <div class="mp-item" data-tool="pm_regard" title="Regard / Chambre">R</div>
    </div>

    <div class="mp-hint">
      ‚Ä¢ <b>Cote</b> (tablette) : place la cible ‚Üí <b>D√©part OK</b> ‚Üí vise ‚Üí <b>Arriv√©e OK</b> (trait en live).<br>
      ‚Ä¢ <b>PB/B/V/R</b> : clique pour poser le symbole (la cible sert d‚Äôaide de pointage).
    </div>
  </div>

  <!-- Color picker -->
  <div id="colorPicker" class="glass readable">
    <div class="dot sel" style="background:#e74c3c;" data-color="#e74c3c" title="Rouge"></div>
    <div class="dot" style="background:#f1c40f;" data-color="#f1c40f" title="Jaune"></div>
    <div class="dot" style="background:#3aa0ff;" data-color="#3aa0ff" title="Bleu"></div>
    <div class="dot" style="background:#2ed3a8;" data-color="#2ed3a8" title="Vert"></div>
    <div class="dot" style="background:#9b59ff;" data-color="#9b59ff" title="Violet"></div>
    <div class="dot" style="background:#ffffff;" data-color="#ffffff" title="Blanc"></div>
  </div>

  <!-- Dock: lisible -->
  <div class="dock glass readable">
    <button id="btnPan" class="btn-icon active" title="D√©placer"><i class="fa-solid fa-hand"></i></button>
    <button id="btnHome" class="btn-icon" title="Recentrer"><i class="fa-solid fa-house"></i></button>

    <div class="divider"></div>

    <button id="btnZoomOut" class="btn-icon" disabled title="Zoom -"><i class="fa-solid fa-minus"></i></button>
    <button id="btnZoomIn" class="btn-icon" disabled title="Zoom +"><i class="fa-solid fa-plus"></i></button>

    <div class="divider"></div>

    <button id="btnScale" class="btn-icon" disabled title="√âtalonnage"><i class="fa-solid fa-ruler-horizontal"></i></button>
    <button id="btnMeasure" class="btn-icon" disabled title="Mesurer"><i class="fa-solid fa-tape"></i></button>
    <button id="btnMinute" class="btn-icon" disabled title="Plan minute"><i class="fa-solid fa-file-pen"></i></button>

    <div class="divider"></div>

    <button id="btnUndo" class="btn-icon btn-undo" disabled title="Annuler"><i class="fa-solid fa-rotate-left"></i></button>
    <button id="btnDelete" class="btn-icon btn-delete" disabled title="Supprimer"><i class="fa-solid fa-xmark"></i></button>
  </div>

  <div id="touchCursor"><div class="dot"></div></div>

  <!-- Confirm pad: lisible + fixe -->
  <div id="confirmPad" class="glass readable">
    <button id="btnConfirmStart" class="cbtn ok"><i class="fa-solid fa-location-dot"></i> D√©part OK</button>
    <button id="btnConfirmEnd" class="cbtn end" disabled><i class="fa-solid fa-flag-checkered"></i> Arriv√©e OK</button>
    <button id="btnConfirmCancel" class="cbtn cancel" title="Annuler"><i class="fa-solid fa-xmark"></i></button>
  </div>

  <div id="versionLabel">V2.1.6 (SIG Pro)</div>

  <div id="appFrame"></div>
  <div id="canvas-wrapper"><canvas id="c"></canvas></div>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    const CONFIG = Object.freeze({
      PDF_RENDER_SCALE: 3.0,
      EXPORT_MULTIPLIER: 3,
      MAX_ZOOM: 20,
      MIN_DRAW_PX_AT_ZOOM1: 5,
      MEASURE_STROKE: 3,
      SCALE_STROKE: 3,
      SCALE_DASH: [10, 5],
      PM_STROKE: 3,
      STATUS_MS: 3000,
      OCR: { cropWidthRatio: 0.42, cropHeightRatio: 0.42, lang: "eng" },
      SCALE_REGEX: /1\s*[:\/.,]\s*([1-9]\d{1,4})\b/,

      /* Fl√®ches */
      ARROW: {
        length: 14,        // px @ zoom=1
        width: 12,         // px @ zoom=1
        inset: 1.5         // petit recul pour √©viter chevauchement
      }
    });

    const MODES = Object.freeze({
      PAN: "pan",
      SCALE: "scale",
      MEASURE: "measure",
      MINUTE: "minute"
    });

    const PM_TOOLS = Object.freeze({
      COTE: "pm_cote",
      PB: "pm_pb",
      BOUCHON: "pm_bouchon",
      VANNE: "pm_vanne",
      REGARD: "pm_regard"
    });

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    const ui = {
      wrapper: $("#canvas-wrapper"),
      fileInput: $("#fileInput"),
      statusBubble: $("#statusBubble"),
      pageLabel: $("#pageLabel"),
      pageJump: $("#pageJump"),
      scaleBadge: $("#scaleBadge"),
      scaleText: $("#scaleText"),

      btnPrevPage: $("#btnPrevPage"),
      btnNextPage: $("#btnNextPage"),
      btnGoPage: $("#btnGoPage"),

      btnFullscreen: $("#btnFullscreen"),
      btnSave: $("#btnSave"),
      btnClear: $("#btnClear"),

      btnPan: $("#btnPan"),
      btnHome: $("#btnHome"),
      btnZoomIn: $("#btnZoomIn"),
      btnZoomOut: $("#btnZoomOut"),
      btnScale: $("#btnScale"),
      btnMeasure: $("#btnMeasure"),
      btnMinute: $("#btnMinute"),
      btnUndo: $("#btnUndo"),
      btnDelete: $("#btnDelete"),

      colorPicker: $("#colorPicker"),
      minutePanel: $("#minutePanel"),
      minuteToolLabel: $("#minuteToolLabel"),

      touchCursor: $("#touchCursor"),
      confirmPad: $("#confirmPad"),
      btnConfirmStart: $("#btnConfirmStart"),
      btnConfirmEnd: $("#btnConfirmEnd"),
      btnConfirmCancel: $("#btnConfirmCancel"),
    };

    const Status = (() => {
      let timer;
      function show(message, type = "normal") {
        ui.statusBubble.textContent = message;
        ui.statusBubble.classList.remove("success","warning","error");
        if (type === "success") ui.statusBubble.classList.add("success");
        if (type === "warning") ui.statusBubble.classList.add("warning");
        if (type === "error") ui.statusBubble.classList.add("error");
        ui.statusBubble.classList.add("visible");
        clearTimeout(timer);
        timer = setTimeout(() => ui.statusBubble.classList.remove("visible"), CONFIG.STATUS_MS);
      }
      return { show };
    })();

    const state = {
      mode: MODES.PAN,
      pmTool: PM_TOOLS.COTE,

      pdfDoc: null,
      pageCount: 0,
      currentPage: 1,

      pixelsPerMeter: 0,
      initialZoom: 0.05,
      currentColor: "#e74c3c",

      isDragging: false,
      lastClientX: 0,
      lastClientY: 0,

      perPage: new Map(),

      cursorActive: false,
      cursorPhase: "idle",
      startPoint: null,
      previewLine: null,

      _pcDrawing: false,
      _pcStart: null,
      _pcLine: null
    };

    const canvas = new fabric.Canvas("c", { selection: true, preserveObjectStacking: true });

    function setDisabledAll(disabled) {
      [
        ui.btnPan, ui.btnHome, ui.btnZoomIn, ui.btnZoomOut, ui.btnScale,
        ui.btnMeasure, ui.btnMinute, ui.btnUndo, ui.btnDelete, ui.btnSave
      ].forEach(b => b.disabled = disabled);
      ui.btnClear.disabled = false;
      ui.btnFullscreen.disabled = false;
    }

    function syncMeasureButton() {
      ui.btnMeasure.disabled = !(state.pixelsPerMeter > 0);
      if (state.pixelsPerMeter > 0) {
        ui.scaleBadge.classList.add("ok");
        ui.scaleText.textContent = "D√©tect√©e";
      } else {
        ui.scaleBadge.classList.remove("ok");
        ui.scaleText.textContent = "Non d√©tect√©e";
      }
    }

    function clampZoom(z) {
      return Math.max(state.initialZoom, Math.min(CONFIG.MAX_ZOOM, z));
    }

    function clampViewportToBackground() {
      const bg = canvas.backgroundImage;
      if (!bg) return;

      const zoom = canvas.getZoom();
      const contentW = bg.width * zoom;
      const contentH = bg.height * zoom;
      const vpt = canvas.viewportTransform;

      if (contentW <= canvas.width) vpt[4] = (canvas.width - contentW) / 2;
      else {
        const minX = canvas.width - contentW;
        const maxX = 0;
        vpt[4] = Math.min(maxX, Math.max(minX, vpt[4]));
      }

      if (contentH <= canvas.height) vpt[5] = (canvas.height - contentH) / 2;
      else {
        const minY = canvas.height - contentH;
        const maxY = 0;
        vpt[5] = Math.min(maxY, Math.max(minY, vpt[5]));
      }
    }

    function resizeCanvas() {
      canvas.setWidth(ui.wrapper.clientWidth);
      canvas.setHeight(ui.wrapper.clientHeight);
      clampViewportToBackground();
      canvas.requestRenderAll();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function resetViewToCenter() {
      canvas.setZoom(state.initialZoom);
      const vpt = canvas.viewportTransform;
      vpt[0] = state.initialZoom; vpt[3] = state.initialZoom;
      vpt[4] = (canvas.width - (canvas.backgroundImage?.width || 0) * state.initialZoom) / 2;
      vpt[5] = (canvas.height - (canvas.backgroundImage?.height || 0) * state.initialZoom) / 2;
      clampViewportToBackground();
      canvas.requestRenderAll();
    }

    function applyZoom(factor) {
      const zoom = clampZoom(canvas.getZoom() * factor);
      canvas.zoomToPoint({ x: canvas.width / 2, y: canvas.height / 2 }, zoom);
      clampViewportToBackground();
      canvas.requestRenderAll();
    }

    function setMode(mode) {
      state.mode = mode;

      [ui.btnPan, ui.btnScale, ui.btnMeasure, ui.btnMinute].forEach(b => b.classList.remove("active"));
      if (mode === MODES.PAN) ui.btnPan.classList.add("active");
      if (mode === MODES.SCALE) ui.btnScale.classList.add("active");
      if (mode === MODES.MEASURE) ui.btnMeasure.classList.add("active");
      if (mode === MODES.MINUTE) ui.btnMinute.classList.add("active");

      ui.colorPicker.classList.toggle("show", mode === MODES.MEASURE || mode === MODES.MINUTE);
      ui.minutePanel.classList.toggle("show", mode === MODES.MINUTE);

      if (mode === MODES.PAN) {
        canvas.selection = true;
        canvas.forEachObject(o => o.selectable = true);
        canvas.defaultCursor = "grab";
        if (state.pdfDoc) Status.show("Mode D√©placement");
      } else {
        canvas.selection = false;
        canvas.forEachObject(o => o.selectable = false);
        canvas.discardActiveObject();
        canvas.requestRenderAll();
        canvas.defaultCursor = "crosshair";

        if (mode === MODES.SCALE) Status.show("‚ö†Ô∏è √âtalonnage : trace une cote connue", "warning");
        if (mode === MODES.MEASURE) Status.show("‚úÖ Mode Mesure", "success");
        if (mode === MODES.MINUTE) Status.show("üìù Mode Plan minute", "success");
      }

      if (mode === MODES.PAN || mode === MODES.SCALE) cancelCursorFlow();

      syncMeasureButton();
    }

    function requestFullScreen() {
      const el = document.documentElement;
      if (el.requestFullscreen) return el.requestFullscreen();
      if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
    }
    function exitFullScreen() {
      if (document.exitFullscreen) return document.exitFullscreen();
      if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
    }
    ui.btnFullscreen.addEventListener("click", async () => {
      try {
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          await exitFullScreen();
        } else {
          await requestFullScreen();
        }
      } catch (e) {}
    });

    $$("#colorPicker .dot").forEach(dot => {
      dot.addEventListener("click", () => {
        $$("#colorPicker .dot").forEach(d => d.classList.remove("sel"));
        dot.classList.add("sel");
        state.currentColor = dot.getAttribute("data-color");

        const active = canvas.getActiveObject();
        if (active && active.type === "group") {
          const lineObj = active.getObjects().find(o => o.type === "line");
          if (lineObj) {
            lineObj.set("stroke", state.currentColor);
            // recolorer aussi les fl√®ches si pr√©sentes
            active.getObjects().forEach(o => {
              if (o.type === "triangle") o.set("fill", state.currentColor);
            });
            canvas.requestRenderAll();
            saveMeasuresForPage(state.currentPage);
          }
        }
      });
    });

    function setPmTool(tool) {
      state.pmTool = tool;
      $$("#minutePanel .mp-item").forEach(el => el.classList.remove("active"));
      const btn = $(`#minutePanel .mp-item[data-tool="${tool}"]`);
      if (btn) btn.classList.add("active");

      const labels = {
        [PM_TOOLS.COTE]: "Outil : Cote",
        [PM_TOOLS.PB]: "Outil : Prise branchement",
        [PM_TOOLS.BOUCHON]: "Outil : Bouchon",
        [PM_TOOLS.VANNE]: "Outil : Vanne",
        [PM_TOOLS.REGARD]: "Outil : Regard",
      };
      ui.minuteToolLabel.textContent = labels[tool] || "Outil : -";
    }
    $$("#minutePanel .mp-item").forEach(el => {
      el.addEventListener("click", () => setPmTool(el.getAttribute("data-tool")));
    });

    function isTooSmall(distPx) {
      const zoom = canvas.getZoom();
      return distPx < (CONFIG.MIN_DRAW_PX_AT_ZOOM1 / zoom);
    }

    function lineAngleDeg(x1,y1,x2,y2){
      return Math.atan2(y2-y1, x2-x1) * 180 / Math.PI;
    }

    function makeLine(x1, y1, x2, y2, mode) {
      const zoom = canvas.getZoom();
      const stroke = (mode === MODES.SCALE ? CONFIG.SCALE_STROKE : (mode === MODES.MEASURE ? CONFIG.MEASURE_STROKE : CONFIG.PM_STROKE)) / zoom;
      const isScale = mode === MODES.SCALE;
      const color = (mode === MODES.MEASURE || mode === MODES.MINUTE) ? state.currentColor : "#ffffff";

      return new fabric.Line([x1, y1, x2, y2], {
        strokeWidth: stroke,
        stroke: isScale ? "#2c3e50" : color,
        strokeDashArray: isScale ? CONFIG.SCALE_DASH : null,
        originX: "center",
        originY: "center",
        selectable: true,
        evented: true
      });
    }

    function makeArrowHead(x, y, angleDeg, color) {
      const z = canvas.getZoom();
      const w = CONFIG.ARROW.width / z;
      const h = CONFIG.ARROW.length / z;
      return new fabric.Triangle({
        left: x,
        top: y,
        originX: "center",
        originY: "center",
        width: w,
        height: h,
        angle: angleDeg,
        fill: color,
        selectable: false,
        evented: false
      });
    }

    // Fl√®ches vers l‚Äôext√©rieur (start: angle+180, end: angle)
    function makeOutwardArrows(x1,y1,x2,y2,color) {
      const ang = lineAngleDeg(x1,y1,x2,y2);
      const z = canvas.getZoom();
      const inset = CONFIG.ARROW.inset / z;

      // petit recul le long de la ligne pour √©viter recouvrir l‚Äôextr√©mit√©
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.hypot(dx,dy) || 1;
      const ux = dx/len, uy = dy/len;

      const sx = x1 - ux*inset, sy = y1 - uy*inset;
      const ex = x2 + ux*inset, ey = y2 + uy*inset;

      const aEnd = makeArrowHead(ex, ey, ang, color);
      const aStart = makeArrowHead(sx, sy, ang + 180, color);
      return [aStart, aEnd];
    }

    function makeLabel(textValue, x, y) {
      const zoom = canvas.getZoom();
      return new fabric.Text(textValue, {
        fontSize: 14 / zoom,
        fill: "white",
        backgroundColor: "rgba(0,0,0,0.72)",
        left: x,
        top: y,
        originX: "center",
        originY: "bottom",
        fontFamily: "Segoe UI"
      });
    }

    function pmSymbol(pbKind, x, y) {
      const z = canvas.getZoom();
      const s = 18 / z;

      if (pbKind === PM_TOOLS.PB) {
        const stem = new fabric.Line([0, -s, 0, s], { stroke: "#00e5ff", strokeWidth: 3 / z });
        const arm  = new fabric.Line([-s, 0, s, 0], { stroke: "#00e5ff", strokeWidth: 3 / z });
        const circ = new fabric.Circle({ radius: 4 / z, fill: "#00e5ff", left: -4 / z, top: -4 / z });
        const g = new fabric.Group([stem, arm, circ], { left:x, top:y, originX:"center", originY:"center" });
        g.isPm = true; g.pmKind = "PB";
        return g;
      }
      if (pbKind === PM_TOOLS.BOUCHON) {
        const c = new fabric.Circle({ radius: 7 / z, fill: "#ffcc00", stroke: "rgba(0,0,0,0.35)", strokeWidth: 1 / z });
        const g = new fabric.Group([c], { left:x, top:y, originX:"center", originY:"center" });
        g.isPm = true; g.pmKind = "BOUCHON";
        return g;
      }
      if (pbKind === PM_TOOLS.VANNE) {
        const tri1 = new fabric.Triangle({ width: 14 / z, height: 12 / z, fill: "transparent", stroke: "#2ed3a8", strokeWidth: 2 / z, originX:"center", originY:"center", angle: 90 });
        const tri2 = new fabric.Triangle({ width: 14 / z, height: 12 / z, fill: "transparent", stroke: "#2ed3a8", strokeWidth: 2 / z, originX:"center", originY:"center", angle: -90 });
        const bar  = new fabric.Line([-16 / z, 0, 16 / z, 0], { stroke: "#2ed3a8", strokeWidth: 2 / z });
        tri1.set({ left: -6 / z, top: 0 });
        tri2.set({ left:  6 / z, top: 0 });
        const g = new fabric.Group([bar, tri1, tri2], { left:x, top:y, originX:"center", originY:"center" });
        g.isPm = true; g.pmKind = "VANNE";
        return g;
      }
      if (pbKind === PM_TOOLS.REGARD) {
        const r = new fabric.Rect({ width: 18 / z, height: 14 / z, fill: "rgba(255,255,255,0.08)", stroke: "#ffffff", strokeWidth: 2 / z, rx: 3 / z, ry: 3 / z });
        const g = new fabric.Group([r], { left:x, top:y, originX:"center", originY:"center" });
        g.isPm = true; g.pmKind = "REGARD";
        return g;
      }
      return null;
    }

    function saveMeasuresForPage(pageNumber) {
      const json = canvas.toDatalessJSON(["isMeasure","measureValue","isPm","pmKind","pmValue"]);
      state.perPage.set(pageNumber, {
        json,
        pixelsPerMeter: state.pixelsPerMeter || 0
      });
    }

    function restoreMeasuresForPage(pageNumber) {
      const saved = state.perPage.get(pageNumber);

      state.pixelsPerMeter = (saved?.pixelsPerMeter && saved.pixelsPerMeter > 0) ? saved.pixelsPerMeter : 0;
      syncMeasureButton();

      if (!saved?.json) return;

      canvas.getObjects().forEach(o => { if (o !== canvas.backgroundImage) canvas.remove(o); });

      canvas.loadFromJSON(saved.json, () => {
        if (state.mode !== MODES.PAN) canvas.forEachObject(o => o.selectable = false);
        canvas.requestRenderAll();
      });
    }

    async function loadPdfFile(file) {
      Status.show("‚è≥ Chargement PDF...");
      const buffer = await file.arrayBuffer();
      const typed = new Uint8Array(buffer);
      state.pdfDoc = await pdfjsLib.getDocument(typed).promise;

      state.pageCount = state.pdfDoc.numPages;
      state.currentPage = 1;
      state.perPage.clear();
      state.pixelsPerMeter = 0;
      syncMeasureButton();

      Status.show(`‚úÖ PDF charg√© (${state.pageCount} pages)`, "success");
      updatePagerUI();
      await renderPage(1, { restore: true });
    }

    async function renderPage(pageNumber, { restore = true } = {}) {
      if (!state.pdfDoc) return;

      if (state.currentPage && state.currentPage !== pageNumber) saveMeasuresForPage(state.currentPage);

      state.currentPage = pageNumber;
      updatePagerUI();
      Status.show(`‚è≥ Rendu page ${pageNumber}...`);

      const page = await state.pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: CONFIG.PDF_RENDER_SCALE });

      const tempCanvas = document.createElement("canvas");
      const ctx = tempCanvas.getContext("2d", { willReadFrequently: true });
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;

      await page.render({ canvasContext: ctx, viewport }).promise;
      const dataUrl = tempCanvas.toDataURL("image/png");

      await new Promise((resolve) => {
        fabric.Image.fromURL(dataUrl, (img) => {
          setupBackground(img);
          if (restore) restoreMeasuresForPage(pageNumber);
          resolve();
        }, { crossOrigin: "anonymous" });
      });

      await performVisualOCR(tempCanvas).catch(() => {});
      Status.show(`‚úÖ Page ${pageNumber} pr√™te`, "success");
    }

    function setupBackground(img) {
      cancelCursorFlow();

      canvas.clear();
      canvas.setViewportTransform([1,0,0,1,0,0]);

      const ratio = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.98;
      state.initialZoom = ratio;

      canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
        originX:"left", originY:"top", left:0, top:0, selectable:false, evented:false
      });

      resetViewToCenter();
      setDisabledAll(false);
      ui.btnMinute.disabled = false;
      ui.btnScale.disabled = false;
      ui.btnZoomIn.disabled = false;
      ui.btnZoomOut.disabled = false;
      ui.btnUndo.disabled = false;
      ui.btnDelete.disabled = false;
      ui.btnSave.disabled = false;

      setMode(MODES.PAN);
    }

    function updatePagerUI() {
      const hasPdf = !!state.pdfDoc;
      ui.btnPrevPage.disabled = !hasPdf || state.currentPage <= 1;
      ui.btnNextPage.disabled = !hasPdf || state.currentPage >= state.pageCount;
      ui.pageJump.disabled = !hasPdf;
      ui.btnGoPage.disabled = !hasPdf;

      ui.pageLabel.textContent = hasPdf ? `Page ${state.currentPage} / ${state.pageCount}` : "Page - / -";
      ui.pageJump.min = 1;
      ui.pageJump.max = state.pageCount || 1;
      ui.pageJump.value = hasPdf ? state.currentPage : "";
    }

    ui.btnPrevPage.addEventListener("click", () => {
      if (state.currentPage > 1) renderPage(state.currentPage - 1, { restore:true });
    });
    ui.btnNextPage.addEventListener("click", () => {
      if (state.currentPage < state.pageCount) renderPage(state.currentPage + 1, { restore:true });
    });
    ui.btnGoPage.addEventListener("click", () => {
      const n = parseInt(ui.pageJump.value, 10);
      if (!Number.isFinite(n)) return;
      const target = Math.max(1, Math.min(state.pageCount, n));
      renderPage(target, { restore:true });
    });
    ui.pageJump.addEventListener("keydown", (e) => {
      if (e.key === "Enter") ui.btnGoPage.click();
    });

    function parseScaleString(text) {
      const clean = String(text || "")
        .replace(/[Oo]/g, "0")
        .replace(/l/g, "1");

      const match = clean.match(CONFIG.SCALE_REGEX);
      if (!match?.[1]) return false;

      const scaleVal = parseInt(match[1], 10);
      if (!(scaleVal > 0)) return false;

      state.pixelsPerMeter = (72 * CONFIG.PDF_RENDER_SCALE * 39.3701) / scaleVal;

      Status.show(`‚úÖ √âchelle 1/${scaleVal} d√©tect√©e !`, "success");
      syncMeasureButton();
      saveMeasuresForPage(state.currentPage);
      return true;
    }

    async function performVisualOCR(canvasEl) {
      Status.show("üëÅÔ∏è OCR √©chelle...");
      const crop = document.createElement("canvas");
      const ctx = crop.getContext("2d", { willReadFrequently: true });

      const w = Math.floor(canvasEl.width * CONFIG.OCR.cropWidthRatio);
      const h = Math.floor(canvasEl.height * CONFIG.OCR.cropHeightRatio);

      crop.width = w;
      crop.height = h;

      ctx.drawImage(canvasEl, 0, 0, w, h, 0, 0, w, h);

      const result = await Tesseract.recognize(crop, CONFIG.OCR.lang);
      const ok = parseScaleString(result?.data?.text);

      if (!ok) {
        state.pixelsPerMeter = 0;
        syncMeasureButton();
        Status.show("‚ö†Ô∏è √âchelle non trouv√©e. √âtalonnage manuel.", "warning");
      }
    }

    ui.btnPan.addEventListener("click", () => setMode(MODES.PAN));
    ui.btnScale.addEventListener("click", () => setMode(MODES.SCALE));
    ui.btnMeasure.addEventListener("click", () => {
      if (!(state.pixelsPerMeter > 0)) {
        alert("Aucune √©chelle d√©finie pour cette page !");
        setMode(MODES.SCALE);
        return;
      }
      setMode(MODES.MEASURE);
    });
    ui.btnMinute.addEventListener("click", () => setMode(MODES.MINUTE));

    ui.btnHome.addEventListener("click", () => resetViewToCenter());
    ui.btnZoomIn.addEventListener("click", () => applyZoom(1.2));
    ui.btnZoomOut.addEventListener("click", () => applyZoom(0.8));

    canvas.on("mouse:wheel", (opt) => {
      let zoom = canvas.getZoom();
      zoom *= 0.999 ** opt.e.deltaY;
      zoom = clampZoom(zoom);
      canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
      clampViewportToBackground();
      canvas.requestRenderAll();
      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

    (() => {
      let isPinching = false;
      let startDist = 0;
      let startZoom = 1;
      let lastMid = null;

      function dist(t1, t2) {
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
      }
      function midpoint(t1, t2) {
        return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
      }

      function onTouchStart(e) {
        if (e.touches.length === 2) {
          isPinching = true;
          startDist = dist(e.touches[0], e.touches[1]);
          startZoom = canvas.getZoom();
          lastMid = midpoint(e.touches[0], e.touches[1]);
          e.preventDefault();
        }
      }

      function onTouchMove(e) {
        if (!isPinching) return;
        if (e.touches.length !== 2) return;

        const d = dist(e.touches[0], e.touches[1]);
        const ratio = d / (startDist || 1);
        let newZoom = clampZoom(startZoom * ratio);

        const mid = midpoint(e.touches[0], e.touches[1]);
        const rect = ui.wrapper.getBoundingClientRect();
        const canvasMid = { x: mid.x - rect.left, y: mid.y - rect.top };

        canvas.zoomToPoint(canvasMid, newZoom);

        if (lastMid) {
          const dx = mid.x - lastMid.x;
          const dy = mid.y - lastMid.y;
          const vpt = canvas.viewportTransform;
          vpt[4] += dx;
          vpt[5] += dy;
        }

        clampViewportToBackground();
        lastMid = mid;
        canvas.requestRenderAll();
        e.preventDefault();
      }

      function onTouchEnd(e) {
        if (e.touches.length < 2) {
          isPinching = false;
          startDist = 0;
          lastMid = null;
        }
      }

      ui.wrapper.addEventListener("touchstart", onTouchStart, { passive: false });
      ui.wrapper.addEventListener("touchmove", onTouchMove, { passive: false });
      ui.wrapper.addEventListener("touchend", onTouchEnd, { passive: false });
      ui.wrapper.addEventListener("touchcancel", onTouchEnd, { passive: false });
    })();

    ui.fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try { await loadPdfFile(file); }
      catch (err) { console.error(err); Status.show("Erreur chargement PDF.", "error"); }
      finally { ui.fileInput.value = ""; }
    });

    ui.btnClear.addEventListener("click", () => {
      if (!confirm("Tout effacer (page courante) ?")) return;
      canvas.getObjects().forEach(o => { if (o !== canvas.backgroundImage) canvas.remove(o); });
      canvas.discardActiveObject();
      canvas.requestRenderAll();
      Status.show("Page nettoy√©e");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    ui.btnSave.addEventListener("click", () => {
      canvas.discardActiveObject();
      canvas.requestRenderAll();
      const dataURL = canvas.toDataURL({ format:"png", quality:1, multiplier: CONFIG.EXPORT_MULTIPLIER });
      const a = document.createElement("a");
      a.download = `plan_page_${state.currentPage}.png`;
      a.href = dataURL;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    ui.btnUndo.addEventListener("click", () => {
      const objs = canvas.getObjects().filter(o => o !== canvas.backgroundImage);
      if (!objs.length) return;
      canvas.remove(objs[objs.length - 1]);
      canvas.requestRenderAll();
      Status.show("Annul√©");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    ui.btnDelete.addEventListener("click", () => {
      const actives = canvas.getActiveObjects();
      if (!actives.length) return;
      actives.forEach(obj => canvas.remove(obj));
      canvas.discardActiveObject();
      canvas.requestRenderAll();
      Status.show("Supprim√©");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    /* ====== CURSOR & CONFIRM WORKFLOW ====== */
    function showCursorAt(clientX, clientY) {
      ui.touchCursor.style.display = "block";
      ui.touchCursor.style.transform = `translate(${clientX - 27}px, ${clientY - 27}px)`;
    }

    function hideCursor() {
      ui.touchCursor.style.display = "none";
      ui.touchCursor.style.transform = `translate(-9999px,-9999px)`;
    }

    function cursorCenterClient() {
      const r = ui.touchCursor.getBoundingClientRect();
      return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }

    function clientToFabricPoint(clientX, clientY) {
      const rect = ui.wrapper.getBoundingClientRect();
      const xCanvas = clientX - rect.left;
      const yCanvas = clientY - rect.top;

      const pt = new fabric.Point(xCanvas, yCanvas);
      const inv = fabric.util.invertTransform(canvas.viewportTransform);
      const p = fabric.util.transformPoint(pt, inv);
      return { x: p.x, y: p.y };
    }

    function getTargetFabricPoint() {
      const c = cursorCenterClient();
      return clientToFabricPoint(c.x, c.y);
    }

    function isTabletTouchDevice() {
      return ("ontouchstart" in window) || navigator.maxTouchPoints > 0;
    }

    function startCursorFlow() {
      state.cursorActive = true;
      state.cursorPhase = "start";
      state.startPoint = null;

      ui.confirmPad.classList.add("show");
      ui.btnConfirmEnd.disabled = true;
      Status.show("Place la cible, puis D√©part OK", "success");
    }

    function cancelCursorFlow() {
      state.cursorActive = false;
      state.cursorPhase = "idle";
      state.startPoint = null;

      if (state.previewLine) {
        canvas.remove(state.previewLine);
        state.previewLine = null;
        canvas.requestRenderAll();
      }

      ui.confirmPad.classList.remove("show");
      hideCursor();
    }

    ui.btnConfirmCancel.addEventListener("click", () => cancelCursorFlow());

    ui.btnConfirmStart.addEventListener("click", () => {
      if (!state.cursorActive) return;

      const p = getTargetFabricPoint();
      state.startPoint = p;
      state.cursorPhase = "end";

      ui.btnConfirmEnd.disabled = false;

      if (state.previewLine) canvas.remove(state.previewLine);
      state.previewLine = makeLine(p.x, p.y, p.x, p.y, state.mode);
      state.previewLine.selectable = false;
      state.previewLine.evented = false;
      canvas.add(state.previewLine);
      canvas.requestRenderAll();

      Status.show("Vise l‚Äôarriv√©e, puis Arriv√©e OK", "success");
    });

    ui.btnConfirmEnd.addEventListener("click", () => {
      if (!state.cursorActive) return;
      if (!state.startPoint) return;

      const end = getTargetFabricPoint();
      const start = state.startPoint;

      const distPx = Math.hypot(end.x - start.x, end.y - start.y);
      if (isTooSmall(distPx)) {
        Status.show("Trop court", "warning");
        return;
      }

      if (state.previewLine) {
        canvas.remove(state.previewLine);
        state.previewLine = null;
      }

      if (state.mode === MODES.SCALE) {
        const input = prompt("Distance r√©elle en M√àTRES ? (√©chelle page)", "1.0");
        const meters = parseFloat((input || "").replace(",", "."));
        if (!(meters > 0)) { cancelCursorFlow(); return; }

        state.pixelsPerMeter = distPx / meters;
        syncMeasureButton();
        Status.show(`‚úÖ √âtalonn√© : 1m = ${state.pixelsPerMeter.toFixed(2)} px`, "success");
        saveMeasuresForPage(state.currentPage);

        cancelCursorFlow();
        setMode(MODES.MEASURE);
        return;
      }

      if (state.mode === MODES.MEASURE) {
        if (!(state.pixelsPerMeter > 0)) {
          Status.show("‚ö†Ô∏è Pas d‚Äô√©chelle pour cette page", "warning");
          cancelCursorFlow();
          setMode(MODES.SCALE);
          return;
        }

        const meters = distPx / state.pixelsPerMeter;
        const metersStr = `${meters.toFixed(2)} m`;

        const line = makeLine(start.x, start.y, end.x, end.y, MODES.MEASURE);
        const [aStart, aEnd] = makeOutwardArrows(start.x, start.y, end.x, end.y, state.currentColor);

        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2 - 15 / canvas.getZoom();
        const label = makeLabel(metersStr, midX, midY);

        const group = new fabric.Group([line, aStart, aEnd, label], { selectable: true });
        group.isMeasure = true;
        group.measureValue = meters.toFixed(2);

        canvas.add(group);
        canvas.setActiveObject(group);
        canvas.requestRenderAll();
        saveMeasuresForPage(state.currentPage);

        Status.show("Mesure ajout√©e", "success");
        cancelCursorFlow();
        return;
      }

      if (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE) {
        const input = prompt("Cote terrain (m) ? (ex: 0.80)", "1.00");
        const meters = parseFloat((input || "").replace(",", "."));
        if (!(meters > 0)) { cancelCursorFlow(); return; }

        const metersStr = `${meters.toFixed(2)} m`;

        const line = makeLine(start.x, start.y, end.x, end.y, MODES.MINUTE);
        const [aStart, aEnd] = makeOutwardArrows(start.x, start.y, end.x, end.y, state.currentColor);

        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2 - 15 / canvas.getZoom();
        const label = makeLabel(metersStr, midX, midY);

        const group = new fabric.Group([line, aStart, aEnd, label], { selectable:true });
        group.isPm = true;
        group.pmKind = "COTE";
        group.pmValue = meters.toFixed(2);

        canvas.add(group);
        canvas.setActiveObject(group);
        canvas.requestRenderAll();
        saveMeasuresForPage(state.currentPage);

        Status.show("Cote plan minute ajout√©e", "success");
        cancelCursorFlow();
        return;
      }

      cancelCursorFlow();
    });

    function updateLiveLineToTarget() {
      if (!state.cursorActive) return;
      if (state.cursorPhase !== "end") return;
      if (!state.previewLine) return;

      const end = getTargetFabricPoint();
      state.previewLine.set({ x2: end.x, y2: end.y });
      canvas.requestRenderAll();
    }

    function getClientPos(evt) {
      if (evt.touches && evt.touches.length > 0) return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
      return { x: evt.clientX, y: evt.clientY };
    }

    canvas.on("mouse:down", (o) => {
      const evt = o.e;
      const client = getClientPos(evt);

      if (o.target && state.mode === MODES.PAN) return;

      if (state.mode === MODES.PAN) {
        state.isDragging = true;
        state.lastClientX = client.x;
        state.lastClientY = client.y;
        canvas.setCursor("grabbing");
        return;
      }

      const tablet = isTabletTouchDevice();
      const wantsCursorFlow =
        tablet && (state.mode === MODES.MEASURE || state.mode === MODES.SCALE || (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE));

      if (state.mode === MODES.MINUTE && state.pmTool !== PM_TOOLS.COTE) {
        const p = canvas.getPointer(evt);
        const sym = pmSymbol(state.pmTool, p.x, p.y);
        if (sym) {
          canvas.add(sym);
          canvas.setActiveObject(sym);
          canvas.requestRenderAll();
          saveMeasuresForPage(state.currentPage);
          Status.show("Symbole ajout√©", "success");
        }
        return;
      }

      if (wantsCursorFlow) {
        if (!state.cursorActive) startCursorFlow();
        showCursorAt(client.x, client.y);
        updateLiveLineToTarget();
        evt.preventDefault?.();
        return;
      }

      if (evt.touches && evt.touches.length >= 2) return;

      state._pcDrawing = true;
      const p = canvas.getPointer(evt);
      state._pcStart = { x: p.x, y: p.y };
      state._pcLine = makeLine(p.x, p.y, p.x, p.y, state.mode);
      canvas.add(state._pcLine);
    });

    canvas.on("mouse:move", (o) => {
      const evt = o.e;
      const client = getClientPos(evt);

      if (state.isDragging) {
        const vpt = canvas.viewportTransform;
        vpt[4] += client.x - state.lastClientX;
        vpt[5] += client.y - state.lastClientY;
        state.lastClientX = client.x;
        state.lastClientY = client.y;
        clampViewportToBackground();
        canvas.requestRenderAll();
        return;
      }

      if (state.cursorActive) {
        showCursorAt(client.x, client.y);
        updateLiveLineToTarget();
        return;
      }

      if (state._pcDrawing && state._pcLine) {
        const p = canvas.getPointer(evt);
        state._pcLine.set({ x2: p.x, y2: p.y });
        canvas.requestRenderAll();
      }
    });

    canvas.on("mouse:up", (o) => {
      if (state.isDragging) {
        state.isDragging = false;
        canvas.setCursor("grab");
        clampViewportToBackground();
        canvas.requestRenderAll();
        return;
      }

      if (state.cursorActive) return;

      if (!state._pcDrawing || !state._pcLine || !state._pcStart) return;
      state._pcDrawing = false;

      const p = canvas.getPointer(o.e);
      const distPx = Math.hypot(p.x - state._pcStart.x, p.y - state._pcStart.y);

      if (isTooSmall(distPx)) {
        canvas.remove(state._pcLine);
        state._pcLine = null;
        return;
      }

      if (state.mode === MODES.SCALE) {
        setTimeout(() => {
          const input = prompt("Distance r√©elle en M√àTRES ? (√©chelle page)", "1.0");
          const meters = parseFloat((input || "").replace(",", "."));
          if (!(meters > 0)) {
            canvas.remove(state._pcLine);
            state._pcLine = null;
            return;
          }

          state.pixelsPerMeter = distPx / meters;
          syncMeasureButton();
          Status.show(`‚úÖ √âtalonn√© : 1m = ${state.pixelsPerMeter.toFixed(2)} px`, "success");

          canvas.remove(state._pcLine);
          state._pcLine = null;
          saveMeasuresForPage(state.currentPage);
          setMode(MODES.MEASURE);
        }, 50);
        return;
      }

      if (state.mode === MODES.MEASURE) {
        if (!(state.pixelsPerMeter > 0)) {
          Status.show("‚ö†Ô∏è Pas d'√©chelle. √âtalonne.", "warning");
          canvas.remove(state._pcLine);
          state._pcLine = null;
          setMode(MODES.SCALE);
          return;
        }

        const meters = distPx / state.pixelsPerMeter;
        const metersStr = `${meters.toFixed(2)} m`;

        const [aStart, aEnd] = makeOutwardArrows(state._pcStart.x, state._pcStart.y, p.x, p.y, state.currentColor);

        const midX = (state._pcStart.x + p.x) / 2;
        const midY = (state._pcStart.y + p.y) / 2 - 15 / canvas.getZoom();

        const label = makeLabel(metersStr, midX, midY);
        const group = new fabric.Group([state._pcLine, aStart, aEnd, label], { selectable:true });
        group.isMeasure = true;
        group.measureValue = meters.toFixed(2);

        canvas.add(group);
        canvas.remove(state._pcLine);
        canvas.setActiveObject(group);

        state._pcLine = null;
        canvas.requestRenderAll();
        saveMeasuresForPage(state.currentPage);
        return;
      }

      if (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE) {
        setTimeout(() => {
          const input = prompt("Cote terrain (m) ? (ex: 0.80)", "1.00");
          const meters = parseFloat((input || "").replace(",", "."));
          if (!(meters > 0)) {
            canvas.remove(state._pcLine);
            state._pcLine = null;
            return;
          }

          const metersStr = `${meters.toFixed(2)} m`;
          const [aStart, aEnd] = makeOutwardArrows(state._pcStart.x, state._pcStart.y, p.x, p.y, state.currentColor);

          const midX = (state._pcStart.x + p.x) / 2;
          const midY = (state._pcStart.y + p.y) / 2 - 15 / canvas.getZoom();

          const label = makeLabel(metersStr, midX, midY);
          const group = new fabric.Group([state._pcLine, aStart, aEnd, label], { selectable:true });
          group.isPm = true;
          group.pmKind = "COTE";
          group.pmValue = meters.toFixed(2);

          canvas.add(group);
          canvas.remove(state._pcLine);
          canvas.setActiveObject(group);

          state._pcLine = null;
          canvas.requestRenderAll();
          saveMeasuresForPage(state.currentPage);
          Status.show("Cote plan minute ajout√©e", "success");
        }, 50);
      }
    });

    /* ===== Boot ===== */
    setDisabledAll(true);
    updatePagerUI();
    Status.show("Bienvenue", "success");
    setMode(MODES.PAN);
    setPmTool(PM_TOOLS.COTE);
  </script>
</body>
</html>
