<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mesureur R√©seaux - V2.1.1 (Curseur tactile + OCR)</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    :root{
      --bg-color:#1a1a1a;
      --panel-bg:rgba(30,30,30,.85);
      --accent-color:#3498db;
      --text-color:#fff;

      --frame-color: rgba(255,255,255,0.16);
      --frame-inner: rgba(0,0,0,0.55);
      --frame-glow: rgba(52,152,219,0.10);

      --frame-top: 72px;
      --frame-left: 12px;
      --frame-right: 12px;
      --frame-bottom: 18px;
      --frame-radius: 16px;
    }

    body{
      font-family:'Inter','Segoe UI',sans-serif;
      background:var(--bg-color);
      margin:0; padding:0;
      height:100vh; width:100vw;
      overflow:hidden;
      touch-action:none;
      color:var(--text-color);
    }

    .top-bar{
      position:absolute; top:0; left:0; right:0;
      height:60px;
      background:linear-gradient(180deg,rgba(0,0,0,.8) 0%,rgba(0,0,0,0) 100%);
      display:flex; align-items:center; justify-content:space-between;
      padding:0 14px; z-index:60; pointer-events:none;
      gap:12px;
    }
    .app-title{
      font-weight:700; font-size:1.05rem; letter-spacing:1px;
      text-shadow:0 2px 4px rgba(0,0,0,.5);
      opacity:.9;
      pointer-events:auto;
      white-space:nowrap;
    }
    .top-actions{
      display:flex; gap:10px; align-items:center;
      pointer-events:auto;
    }
    .file-btn{
      background:rgba(255,255,255,.1); color:#fff;
      padding:8px 12px; border-radius:8px;
      font-weight:600; font-size:.9rem;
      cursor:pointer;
      transition:background .2s;
      text-decoration:none; border:none;
      display:flex; align-items:center; gap:8px;
    }
    .file-btn:hover{ background:rgba(255,255,255,.25); }
    .file-btn:disabled{ opacity:.35; cursor:not-allowed; }

    .pager{
      display:flex; align-items:center; gap:8px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      padding:6px 10px;
      border-radius:12px;
      pointer-events:auto;
    }
    .pager .page-label{
      font-size:.85rem;
      opacity:.9;
      min-width:88px;
      text-align:center;
      font-variant-numeric: tabular-nums;
    }
    .pager button{
      width:38px; height:38px;
      border-radius:10px;
      border:none;
      background:rgba(255,255,255,.1);
      color:#fff;
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition:transform .15s, background .2s;
    }
    .pager button:hover:not(:disabled){ transform:scale(1.05); background:rgba(255,255,255,.2); }
    .pager button:disabled{ opacity:.25; cursor:not-allowed; }
    .pager input{
      width:56px;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.15);
      color:#fff;
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-size:.9rem;
      text-align:center;
      font-variant-numeric: tabular-nums;
    }

    .bottom-dock{
      position:absolute; bottom:26px; left:50%; transform:translateX(-50%);
      background:var(--panel-bg);
      backdrop-filter:blur(10px);
      padding:10px 16px;
      border-radius:50px;
      border:1px solid rgba(255,255,255,.1);
      display:flex; gap:12px; align-items:center;
      box-shadow:0 10px 30px rgba(0,0,0,.5);
      z-index:60;
    }
    .btn-icon{
      width:48px; height:48px;
      border-radius:50%;
      border:none;
      background:rgba(255,255,255,.1);
      color:#fff;
      font-size:1.1rem;
      cursor:pointer;
      transition:all .2s cubic-bezier(.175,.885,.32,1.275);
      display:flex; align-items:center; justify-content:center;
    }
    .btn-icon:hover:not(:disabled){ transform:scale(1.12); background:rgba(255,255,255,.2); }
    .btn-icon:active{ transform:scale(.95); }
    .btn-icon:disabled{ opacity:.3; cursor:not-allowed; }
    .btn-icon.active{
      background:var(--accent-color);
      box-shadow:0 0 15px var(--accent-color);
      transform:scale(1.06);
    }
    .btn-delete{ color:#e74c3c; }
    .btn-delete:hover{ background:rgba(231,76,60,.2); }
    .btn-undo{ color:#f1c40f; }
    .divider{ width:1px; height:26px; background:rgba(255,255,255,.2); }

    #statusBubble{
      position:absolute; top:78px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.82); color:#fff;
      padding:10px 22px; border-radius:30px;
      font-size:.95rem; font-weight:600;
      pointer-events:none; z-index:100;
      border:1px solid rgba(255,255,255,.15);
      box-shadow:0 5px 15px rgba(0,0,0,.3);
      opacity:0; transition:opacity .25s ease, transform .25s ease;
    }
    #statusBubble.visible{ opacity:1; transform:translateX(-50%) translateY(0); }
    .status-success{ border-color:#27ae60 !important; color:#2ecc71 !important; }
    .status-warning{ border-color:#f39c12 !important; color:#f1c40f !important; }
    .status-error{ border-color:#c0392b !important; color:#e74c3c !important; }

    .total-display{
      position:absolute; bottom:100px; right:18px;
      background:var(--panel-bg); backdrop-filter:blur(5px);
      padding:10px 18px; border-radius:12px;
      border:1px solid rgba(255,255,255,.1);
      text-align:right; pointer-events:none; z-index:55;
      box-shadow:0 5px 15px rgba(0,0,0,.3);
      display:none;
    }
    .total-label{ font-size:.75rem; text-transform:uppercase; color:#aaa; letter-spacing:1px; }
    .total-value{ font-size:1.5rem; font-weight:800; color:var(--accent-color); font-variant-numeric: tabular-nums; }

    .color-palette{
      position:absolute; bottom:92px; left:50%; transform:translateX(-50%);
      display:flex; gap:10px;
      background:rgba(0,0,0,.6);
      padding:8px; border-radius:20px;
      z-index:58;
      transition:opacity .2s;
      opacity:0; pointer-events:none;
    }
    .color-palette.show{ opacity:1; pointer-events:auto; }
    .color-dot{
      width:28px; height:28px; border-radius:50%;
      cursor:pointer;
      border:2px solid rgba(255,255,255,.2);
      transition:transform .15s;
    }
    .color-dot:hover{ transform:scale(1.18); }
    .color-dot.selected{ border:2px solid #fff; transform:scale(1.08); box-shadow:0 0 10px currentColor; }

    #appFrame{
      position:absolute;
      top:var(--frame-top);
      left:var(--frame-left);
      right:var(--frame-right);
      bottom:var(--frame-bottom);
      border-radius:var(--frame-radius);
      pointer-events:none;
      z-index:20;

      border:3px solid var(--frame-color);
      box-shadow:
        0 0 0 1px var(--frame-inner) inset,
        0 0 22px var(--frame-glow),
        0 10px 35px rgba(0,0,0,0.55);
    }

    #canvas-wrapper{
      position:absolute;
      top:var(--frame-top);
      left:var(--frame-left);
      right:var(--frame-right);
      bottom:var(--frame-bottom);
      border-radius:var(--frame-radius);
      overflow:hidden;
      background:#252525;
      z-index:1;
      overscroll-behavior:none;
    }

    /* ===== MINI PANEL PLAN MINUTE ===== */
    #minutePanel{
      position:absolute;
      left: calc(var(--frame-left) + 14px);
      top:  calc(var(--frame-top) + 14px);
      z-index:59;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      padding: 10px;
      display:none;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      min-width: 240px;
    }
    #minutePanel.show{ display:block; }
    .mp-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .mp-title span{
      font-weight:800;
      letter-spacing:0.5px;
      font-size:0.95rem;
      opacity:0.95;
    }
    .mp-grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:8px;
    }
    .mp-item{
      height:44px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#fff;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .15s, background .2s;
      user-select:none;
    }
    .mp-item:hover{ transform: scale(1.05); background: rgba(255,255,255,0.15); }
    .mp-item.active{
      background: var(--accent-color);
      border-color: rgba(255,255,255,0.25);
      box-shadow: 0 0 16px rgba(52,152,219,0.35);
    }
    .mp-hint{
      margin-top:8px;
      font-size:0.82rem;
      opacity:0.85;
      line-height:1.25rem;
    }

    #versionLabel{
      position:fixed; bottom:6px; right:10px;
      opacity:.28; font-size:.72rem;
      z-index:80;
    }

    /* ===== Curseur tactile flottant ===== */
    #touchCursor{
      position:fixed;
      width:22px; height:22px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.95);
      background:rgba(0,0,0,0.28);
      box-shadow:0 8px 18px rgba(0,0,0,0.35);
      z-index:200;
      pointer-events:none;
      display:none;
      transform:translate(-50%, -50%);
    }
    #touchCursor::after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      width:2px; height:14px;
      background:rgba(255,255,255,0.85);
      transform:translate(-50%,-50%);
      border-radius:2px;
    }
    #touchCursor::before{
      content:"";
      position:absolute;
      left:50%; top:50%;
      width:14px; height:2px;
      background:rgba(255,255,255,0.85);
      transform:translate(-50%,-50%);
      border-radius:2px;
    }
    #cursorTag{
      position:fixed;
      z-index:201;
      pointer-events:none;
      display:none;
      transform:translate(-50%, calc(-50% - 22px));
      background:rgba(0,0,0,0.55);
      border:1px solid rgba(255,255,255,0.18);
      padding:4px 8px;
      border-radius:10px;
      font-size:0.78rem;
      font-weight:900;
      color:#fff;
      white-space:nowrap;
    }

    /* Barre de validation tactile */
    #tapConfirmBar{
      position:fixed;
      left:50%;
      bottom:92px;
      transform:translateX(-50%);
      display:none;
      gap:10px;
      z-index:220;
      background:rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.15);
      padding:10px 12px;
      border-radius:18px;
      backdrop-filter: blur(8px);
      align-items:center;
    }
    .tbtn{
      border:none;
      border-radius:14px;
      padding:10px 14px;
      font-weight:900;
      cursor:pointer;
      min-width:120px;
    }
    #btnTapCancel{ background:rgba(231,76,60,.18); color:#e74c3c; }
    #btnTapStep{ background:rgba(52,152,219,.18); color:#6bbcff; }
    #btnTapOK{ background:rgba(46,204,113,.18); color:#2ecc71; display:none; }

    /* Mode immersif (fallback plein √©cran) */
    body.immersive .top-bar{ display:none; }
    body.immersive .bottom-dock{ bottom:14px; }
    body.immersive #canvas-wrapper{
      top: 10px;
      left: 10px;
      right: 10px;
      bottom: 10px;
      border-radius: 14px;
    }
    body.immersive #appFrame{ display:none; }

    @media (max-width: 900px){
      :root{
        --frame-top: 70px;
        --frame-left: 10px;
        --frame-right: 10px;
        --frame-bottom: 16px;
      }
      .btn-icon{ width:54px; height:54px; font-size:1.2rem; }
      .pager button{ width:44px; height:44px; }
      .pager input{ width:64px; padding:10px; }
      .file-btn{ padding:10px 12px; }
      #minutePanel{ min-width: 260px; }
    }
    @media (max-width: 600px){
      :root{
        --frame-top: 68px;
        --frame-left: 10px;
        --frame-right: 10px;
        --frame-bottom: 14px;
        --frame-radius: 14px;
      }
      .app-title{ display:none; }
      .pager .page-label{ min-width:78px; }
      .top-bar{ padding:0 10px; }
      .bottom-dock{ width:92%; justify-content:space-between; gap:10px; padding:10px 14px; }
      #minutePanel{
        left: calc(var(--frame-left) + 10px);
        top:  calc(var(--frame-top) + 10px);
        min-width: 240px;
      }
      .tbtn{ min-width:110px; }
    }
  </style>
</head>

<body>
  <div class="top-bar">
    <div class="app-title"><i class="fa-solid fa-ruler-combined"></i> Mesureur</div>

    <div class="pager" title="Navigation PDF">
      <button id="btnPrevPage" disabled><i class="fa-solid fa-chevron-left"></i></button>
      <div class="page-label" id="pageLabel">Page - / -</div>
      <button id="btnNextPage" disabled><i class="fa-solid fa-chevron-right"></i></button>

      <input id="pageJump" type="number" min="1" step="1" placeholder="N¬∞" disabled />
      <button id="btnGoPage" disabled title="Aller"><i class="fa-solid fa-arrow-right-to-bracket"></i></button>
    </div>

    <div class="top-actions">
      <label for="fileInput" class="file-btn"><i class="fa-solid fa-folder-open"></i> Ouvrir</label>
      <input type="file" id="fileInput" accept=".pdf" style="display:none;">

      <button id="btnFull" class="file-btn" title="Plein √©cran / immersif"><i class="fa-solid fa-expand"></i></button>
      <button id="btnSave" class="file-btn" disabled title="Exporter PNG"><i class="fa-solid fa-floppy-disk"></i></button>
      <button id="btnClear" class="file-btn" title="Tout effacer"
              style="background:rgba(231, 76, 60, 0.2); color:#e74c3c;">
        <i class="fa-solid fa-trash"></i>
      </button>
    </div>
  </div>

  <div id="statusBubble">Bienvenue</div>

  <div class="total-display" id="totalCounter">
    <div class="total-label">Lin√©aire Total (page)</div>
    <div class="total-value" id="totalValue">0.00 m</div>
  </div>

  <div class="color-palette" id="colorPicker">
    <div class="color-dot selected" style="background:#e74c3c;" data-color="#e74c3c" title="√âlec (Rouge)"></div>
    <div class="color-dot" style="background:#f1c40f;" data-color="#f1c40f" title="Gaz (Jaune)"></div>
    <div class="color-dot" style="background:#3498db;" data-color="#3498db" title="Eau (Bleu)"></div>
    <div class="color-dot" style="background:#2ecc71;" data-color="#2ecc71" title="Telecom (Vert)"></div>
    <div class="color-dot" style="background:#9b59b6;" data-color="#9b59b6" title="Fibre (Violet)"></div>
  </div>

  <div id="minutePanel">
    <div class="mp-title">
      <span><i class="fa-solid fa-pen-ruler"></i> Plan minute</span>
      <span style="opacity:.75; font-size:.82rem" id="minuteToolLabel">Outil : Cote</span>
    </div>

    <div class="mp-grid">
      <div class="mp-item active" data-tool="pm_cote" title="Tracer une cote">Cote</div>
      <div class="mp-item" data-tool="pm_pb" title="Prise de branchement">PB</div>
      <div class="mp-item" data-tool="pm_bouchon" title="Bouchon">B</div>
      <div class="mp-item" data-tool="pm_vanne" title="Vanne">V</div>
      <div class="mp-item" data-tool="pm_regard" title="Regard / Chambre">R</div>
    </div>

    <div class="mp-hint">
      ‚Ä¢ <b>Cote</b> : curseur ‚Üí Valider d√©part ‚Üí Valider arriv√©e ‚Üí OK.<br>
      ‚Ä¢ <b>PB/B/V/R</b> : clique pour poser le symbole (couleur = palette).
    </div>
  </div>

  <div class="bottom-dock">
    <button id="btnPan" class="btn-icon active" title="D√©placer"><i class="fa-solid fa-hand"></i></button>
    <button id="btnHome" class="btn-icon" title="Recentrer"><i class="fa-solid fa-house"></i></button>

    <div class="divider"></div>

    <button id="btnZoomOut" class="btn-icon" disabled title="Zoom -"><i class="fa-solid fa-minus"></i></button>
    <button id="btnZoomIn" class="btn-icon" disabled title="Zoom +"><i class="fa-solid fa-plus"></i></button>

    <div class="divider"></div>

    <button id="btnScale" class="btn-icon" disabled title="√âtalonnage"><i class="fa-solid fa-ruler-horizontal"></i></button>
    <button id="btnMeasure" class="btn-icon" disabled title="Mesurer"><i class="fa-solid fa-pen-nib"></i></button>
    <button id="btnMinute" class="btn-icon" disabled title="Plan minute"><i class="fa-solid fa-pen-ruler"></i></button>

    <div class="divider"></div>

    <button id="btnUndo" class="btn-icon btn-undo" disabled title="Annuler"><i class="fa-solid fa-rotate-left"></i></button>
    <button id="btnDelete" class="btn-icon btn-delete" disabled title="Supprimer"><i class="fa-solid fa-xmark"></i></button>
  </div>

  <div id="versionLabel">V2.1.1 (Curseur tactile + OCR)</div>

  <div id="touchCursor"></div>
  <div id="cursorTag">Curseur</div>

  <div id="tapConfirmBar">
    <button id="btnTapCancel" class="tbtn">Annuler</button>
    <button id="btnTapStep" class="tbtn">Valider d√©part</button>
    <button id="btnTapOK" class="tbtn">OK</button>
  </div>

  <div id="appFrame"></div>
  <div id="canvas-wrapper"><canvas id="c"></canvas></div>

  <script>
    /* ============================================================
       Mesureur R√©seaux - V2.1.1
       FIX :
       - Curseur tactile => conversion coords wrapper -> coords Fabric (viewportTransform)
       - OCR r√©tabli + rendu PDF non r√©duit (scale=3.0)
       - OCR √©chelles 1:50..1:10000 + crop cartouche + pre-processing
       - Plein √©cran + fallback immersif
       ============================================================ */

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    const IS_TOUCH = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);

    const CONFIG = Object.freeze({
      PDF_RENDER_SCALE: 3.0,
      EXPORT_MULTIPLIER: 3,

      MAX_ZOOM: 20,
      MIN_DRAW_PX_AT_ZOOM1: 5,

      MEASURE_STROKE: 3,
      SCALE_STROKE: 3,
      SCALE_DASH: [10, 5],
      PM_STROKE: 3,

      STATUS_MS: 3500,

      ARROW_W: 14,
      ARROW_H: 12,

      CURSOR_OFFSET_Y: 60,

      OCR: {
        lang: "eng",
        // crop cartouche : (par d√©faut) bas-droite, zone assez large
        crops: [
          { x: 0.55, y: 0.55, w: 0.45, h: 0.45 }, // bas-droite
          { x: 0.55, y: 0.00, w: 0.45, h: 0.35 }, // haut-droite (fallback)
        ],
      },

      // ‚úÖ accepte beaucoup d'√©chelles
      SCALE_REGEX: /(?:Echelle|√âchelle|Scale|1)\s*[:\/.,]?\s*1?\s*[:\/.,]\s*(25|50|75|100|125|200|250|500|750|1000|2000|2500|5000|10000)\b/i
    });

    const MODES = Object.freeze({
      PAN: "pan",
      SCALE: "scale",
      MEASURE: "measure",
      MINUTE: "minute"
    });

    const PM_TOOLS = Object.freeze({
      COTE: "pm_cote",
      PB: "pm_pb",
      BOUCHON: "pm_bouchon",
      VANNE: "pm_vanne",
      REGARD: "pm_regard"
    });

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    const ui = {
      wrapper: $("#canvas-wrapper"),
      fileInput: $("#fileInput"),
      statusBubble: $("#statusBubble"),
      totalCounter: $("#totalCounter"),
      totalValue: $("#totalValue"),
      colorPicker: $("#colorPicker"),

      minutePanel: $("#minutePanel"),
      minuteToolLabel: $("#minuteToolLabel"),

      touchCursor: $("#touchCursor"),
      cursorTag: $("#cursorTag"),
      tapBar: $("#tapConfirmBar"),
      btnTapCancel: $("#btnTapCancel"),
      btnTapStep: $("#btnTapStep"),
      btnTapOK: $("#btnTapOK"),

      btnFull: $("#btnFull"),

      pager: {
        prev: $("#btnPrevPage"),
        next: $("#btnNextPage"),
        label: $("#pageLabel"),
        jump: $("#pageJump"),
        go: $("#btnGoPage"),
      },

      btn: {
        pan: $("#btnPan"),
        home: $("#btnHome"),
        scale: $("#btnScale"),
        measure: $("#btnMeasure"),
        minute: $("#btnMinute"),
        zoomIn: $("#btnZoomIn"),
        zoomOut: $("#btnZoomOut"),
        undo: $("#btnUndo"),
        del: $("#btnDelete"),
        clear: $("#btnClear"),
        save: $("#btnSave"),
      }
    };

    function setDisabledAll(disabled) {
      Object.values(ui.btn).forEach(b => b.disabled = disabled);
      ui.btn.clear.disabled = false;
    }

    const Status = (() => {
      let timer;
      function show(message, type = "normal") {
        ui.statusBubble.innerText = message;
        ui.statusBubble.className = "";
        ui.statusBubble.classList.add("visible");
        if (type === "success") ui.statusBubble.classList.add("status-success");
        if (type === "warning") ui.statusBubble.classList.add("status-warning");
        if (type === "error") ui.statusBubble.classList.add("status-error");
        clearTimeout(timer);
        timer = setTimeout(() => ui.statusBubble.classList.remove("visible"), CONFIG.STATUS_MS);
      }
      return { show };
    })();

    const state = {
      mode: MODES.PAN,
      pmTool: PM_TOOLS.COTE,

      pixelsPerMeter: 0,
      initialZoom: 0.05,
      currentColor: "#e74c3c",

      isDragging: false,
      lastClientX: 0,
      lastClientY: 0,

      line: null,
      arrows: null,

      // Touch workflow
      step: 0, // 0 idle, 1 choose dep, 2 choose arr, 3 ok
      dep: null,
      arr: null,
      cursorCanvas: { x: 0, y: 0 },

      // PDF
      pdfDoc: null,
      pageCount: 0,
      currentPage: 1,

      perPage: new Map(),
    };

    const canvas = new fabric.Canvas("c", { selection: true, preserveObjectStacking: true });

    function clampViewportToBackground() {
      const bg = canvas.backgroundImage;
      if (!bg) return;

      const zoom = canvas.getZoom();
      const contentW = bg.width * zoom;
      const contentH = bg.height * zoom;

      const vpt = canvas.viewportTransform;

      if (contentW <= canvas.width) vpt[4] = (canvas.width - contentW) / 2;
      else {
        const minX = canvas.width - contentW;
        const maxX = 0;
        vpt[4] = Math.min(maxX, Math.max(minX, vpt[4]));
      }

      if (contentH <= canvas.height) vpt[5] = (canvas.height - contentH) / 2;
      else {
        const minY = canvas.height - contentH;
        const maxY = 0;
        vpt[5] = Math.min(maxY, Math.max(minY, vpt[5]));
      }
    }

    function resizeCanvas() {
      canvas.setWidth(ui.wrapper.clientWidth);
      canvas.setHeight(ui.wrapper.clientHeight);
      clampViewportToBackground();
      canvas.requestRenderAll();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ‚úÖ Conversion wrapper -> coords Fabric (avec zoom/pan)
    function wrapperPointToFabric(wx, wy) {
      const pt = new fabric.Point(wx, wy);
      const inv = fabric.util.invertTransform(canvas.viewportTransform);
      const p2 = fabric.util.transformPoint(pt, inv);
      return { x: p2.x, y: p2.y };
    }

    function clientToWrapper(clientX, clientY) {
      const rect = ui.wrapper.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function setCursorUI(clientX, clientY, label) {
      ui.touchCursor.style.display = "block";
      ui.cursorTag.style.display = "block";
      ui.touchCursor.style.left = clientX + "px";
      ui.touchCursor.style.top  = clientY + "px";
      ui.cursorTag.style.left = clientX + "px";
      ui.cursorTag.style.top  = clientY + "px";
      ui.cursorTag.textContent = label || "Curseur";
    }
    function hideCursorUI() {
      ui.touchCursor.style.display = "none";
      ui.cursorTag.style.display = "none";
    }

    function showTapBar(show) { ui.tapBar.style.display = show ? "flex" : "none"; }

    function setTapBarState(step) {
      if (step === 1) {
        ui.btnTapStep.textContent = "Valider d√©part";
        ui.btnTapStep.style.display = "inline-block";
        ui.btnTapOK.style.display = "none";
      } else if (step === 2) {
        ui.btnTapStep.textContent = "Valider arriv√©e";
        ui.btnTapStep.style.display = "inline-block";
        ui.btnTapOK.style.display = "none";
      } else if (step === 3) {
        ui.btnTapStep.style.display = "none";
        ui.btnTapOK.style.display = "inline-block";
      }
    }

    function cancelTouchMeasure(msg) {
      state.step = 0;
      state.dep = null;
      state.arr = null;

      if (state.line) canvas.remove(state.line);
      if (state.arrows) { canvas.remove(state.arrows.a1); canvas.remove(state.arrows.a2); }
      state.line = null;
      state.arrows = null;

      hideCursorUI();
      showTapBar(false);
      canvas.requestRenderAll();

      if (msg) Status.show(msg, "warning");
    }

    function isTouchMeasureMode() {
      if (!IS_TOUCH) return false;
      if (state.mode === MODES.SCALE) return true;
      if (state.mode === MODES.MEASURE) return true;
      if (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE) return true;
      return false;
    }

    function updateTotal() {
      let total = 0;
      canvas.getObjects().forEach(obj => {
        if (obj.type === "group" && obj.isMeasure) total += Number(obj.measureValue || 0);
      });
      ui.totalValue.innerText = `${total.toFixed(2)} m`;
      ui.totalCounter.style.display = total > 0 ? "block" : "none";
    }

    function syncMeasureButton() { ui.btn.measure.disabled = !state.pixelsPerMeter; }

    function setMode(mode) {
      if (state.step !== 0) cancelTouchMeasure();

      state.mode = mode;

      Object.values(ui.btn).forEach(b => b.classList.remove("active"));
      if (ui.btn[mode]) ui.btn[mode].classList.add("active");

      ui.colorPicker.classList.toggle("show", mode === MODES.MEASURE || mode === MODES.MINUTE);
      ui.minutePanel.classList.toggle("show", mode === MODES.MINUTE);

      if (mode === MODES.PAN) {
        canvas.selection = true;
        canvas.forEachObject(o => o.selectable = true);
        canvas.defaultCursor = "grab";
        if (state.pdfDoc) Status.show("Mode D√©placement");
      } else {
        canvas.selection = false;
        canvas.forEachObject(o => o.selectable = false);
        canvas.discardActiveObject();
        canvas.requestRenderAll();
        canvas.defaultCursor = "crosshair";

        if (mode === MODES.SCALE) Status.show("‚ö†Ô∏è √âtalonnage : curseur + valider", "warning");
        if (mode === MODES.MEASURE) Status.show("‚úÖ Mesure : curseur + valider", "success");
        if (mode === MODES.MINUTE) Status.show("üìù Plan minute : curseur + valider (cotes)", "success");
      }
      syncMeasureButton();
    }

    ui.btn.pan.addEventListener("click", () => setMode(MODES.PAN));
    ui.btn.scale.addEventListener("click", () => setMode(MODES.SCALE));
    ui.btn.measure.addEventListener("click", () => {
      if (!state.pixelsPerMeter) { alert("Aucune √©chelle d√©finie pour cette page !"); setMode(MODES.SCALE); return; }
      setMode(MODES.MEASURE);
    });
    ui.btn.minute.addEventListener("click", () => setMode(MODES.MINUTE));

    ui.btn.home.addEventListener("click", () => resetViewToCenter());

    // Plein √©cran + fallback immersif
    ui.btnFull.addEventListener("click", async () => {
      try {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen?.();
          Status.show("Plein √©cran demand√©", "success");
        } else {
          await document.exitFullscreen?.();
          Status.show("Sortie plein √©cran", "success");
        }
      } catch {
        // fallback immersif
        document.body.classList.toggle("immersive");
        resizeCanvas();
        Status.show(document.body.classList.contains("immersive") ? "Mode immersif" : "Mode normal", "success");
      }
    });

    // Color picker
    $$(".color-dot").forEach(dot => {
      dot.addEventListener("click", () => {
        $$(".color-dot").forEach(d => d.classList.remove("selected"));
        dot.classList.add("selected");
        state.currentColor = dot.getAttribute("data-color");
      });
    });

    function setPmTool(tool) {
      if (state.step !== 0) cancelTouchMeasure("Mesure annul√©e (changement d‚Äôoutil)");
      state.pmTool = tool;
      $$("#minutePanel .mp-item").forEach(el => el.classList.remove("active"));
      const btn = $(`#minutePanel .mp-item[data-tool="${tool}"]`);
      if (btn) btn.classList.add("active");

      const labels = {
        [PM_TOOLS.COTE]: "Outil : Cote",
        [PM_TOOLS.PB]: "Outil : Prise branchement",
        [PM_TOOLS.BOUCHON]: "Outil : Bouchon",
        [PM_TOOLS.VANNE]: "Outil : Vanne",
        [PM_TOOLS.REGARD]: "Outil : Regard",
      };
      ui.minuteToolLabel.textContent = labels[tool] || "Outil : -";
    }
    $$("#minutePanel .mp-item").forEach(el => el.addEventListener("click", () => setPmTool(el.getAttribute("data-tool"))));

    // ===== Zoom / view =====
    function clampZoom(z) { return Math.max(state.initialZoom, Math.min(CONFIG.MAX_ZOOM, z)); }

    function resetViewToCenter() {
      canvas.setZoom(state.initialZoom);
      const vpt = canvas.viewportTransform;
      vpt[0] = state.initialZoom; vpt[3] = state.initialZoom;
      vpt[4] = (canvas.width - (canvas.backgroundImage?.width || 0) * state.initialZoom) / 2;
      vpt[5] = (canvas.height - (canvas.backgroundImage?.height || 0) * state.initialZoom) / 2;
      clampViewportToBackground();
      canvas.requestRenderAll();
    }

    function applyZoom(factor) {
      const zoom = clampZoom(canvas.getZoom() * factor);
      canvas.zoomToPoint({ x: canvas.width / 2, y: canvas.height / 2 }, zoom);
      clampViewportToBackground();
      canvas.requestRenderAll();
    }

    canvas.on("mouse:wheel", (opt) => {
      let zoom = canvas.getZoom();
      zoom *= 0.999 ** opt.e.deltaY;
      zoom = clampZoom(zoom);

      canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
      clampViewportToBackground();
      canvas.requestRenderAll();

      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

    ui.btn.zoomIn.addEventListener("click", () => applyZoom(1.2));
    ui.btn.zoomOut.addEventListener("click", () => applyZoom(0.8));

    // ===== PDF =====
    async function loadPdfFile(file) {
      Status.show("‚è≥ Chargement PDF...", "normal");

      const buffer = await file.arrayBuffer();
      const typed = new Uint8Array(buffer);
      state.pdfDoc = await pdfjsLib.getDocument(typed).promise;

      state.pageCount = state.pdfDoc.numPages;
      state.currentPage = 1;
      state.perPage.clear();

      Status.show(`‚úÖ PDF charg√© (${state.pageCount} pages)`, "success");
      updatePagerUI();
      await renderPage(1, { restoreMeasures: true });
    }

    async function renderPage(pageNumber, { restoreMeasures = true } = {}) {
      if (!state.pdfDoc) return;

      if (state.currentPage && state.currentPage !== pageNumber) saveMeasuresForPage(state.currentPage);
      state.currentPage = pageNumber;
      updatePagerUI();

      Status.show(`‚è≥ Rendu page ${pageNumber}...`, "normal");

      const page = await state.pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: CONFIG.PDF_RENDER_SCALE });

      const tempCanvas = document.createElement("canvas");
      const ctx = tempCanvas.getContext("2d");

      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;

      await page.render({ canvasContext: ctx, viewport }).promise;

      const dataUrl = tempCanvas.toDataURL("image/png");

      await new Promise((resolve) => {
        fabric.Image.fromURL(dataUrl, (img) => {
          setupBackground(img);
          if (restoreMeasures) restoreMeasuresForPage(pageNumber);
          updateTotal();
          resolve();
        }, { crossOrigin: "anonymous" });
      });

      // OCR auto √† l'arriv√©e sur une page (si pas d√©j√† une √©chelle)
      const saved = state.perPage.get(pageNumber);
      const hasScale = (saved?.pixelsPerMeter && saved.pixelsPerMeter > 0);
      if (!hasScale) performCartoucheOCR(tempCanvas).catch(() => {});

      Status.show(`‚úÖ Page ${pageNumber} pr√™te`, "success");
    }

    function updatePagerUI() {
      const hasPdf = !!state.pdfDoc;
      ui.pager.prev.disabled = !hasPdf || state.currentPage <= 1;
      ui.pager.next.disabled = !hasPdf || state.currentPage >= state.pageCount;
      ui.pager.jump.disabled = !hasPdf;
      ui.pager.go.disabled = !hasPdf;

      ui.pager.label.textContent = hasPdf ? `Page ${state.currentPage} / ${state.pageCount}` : "Page - / -";
      ui.pager.jump.min = 1;
      ui.pager.jump.max = state.pageCount || 1;
      ui.pager.jump.value = hasPdf ? state.currentPage : "";
    }

    ui.pager.prev.addEventListener("click", () => { if (state.currentPage > 1) renderPage(state.currentPage - 1, { restoreMeasures: true }); });
    ui.pager.next.addEventListener("click", () => { if (state.currentPage < state.pageCount) renderPage(state.currentPage + 1, { restoreMeasures: true }); });
    ui.pager.go.addEventListener("click", () => {
      const n = parseInt(ui.pager.jump.value, 10);
      if (!Number.isFinite(n)) return;
      const target = Math.max(1, Math.min(state.pageCount, n));
      renderPage(target, { restoreMeasures: true });
    });
    ui.pager.jump.addEventListener("keydown", (e) => { if (e.key === "Enter") ui.pager.go.click(); });

    function setupBackground(img) {
      canvas.clear();
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);

      const ratio = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.98;
      state.initialZoom = ratio;

      canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
        originX: "left",
        originY: "top",
        left: 0,
        top: 0,
        selectable: false,
        evented: false
      });

      resetViewToCenter();
      setDisabledAll(false);
      ui.btn.minute.disabled = false;
      setMode(MODES.PAN);
    }

    function saveMeasuresForPage(pageNumber) {
      const json = canvas.toDatalessJSON(["isMeasure", "measureValue", "isPm", "pmKind"]);
      state.perPage.set(pageNumber, { json, pixelsPerMeter: state.pixelsPerMeter || 0 });
    }

    function restoreMeasuresForPage(pageNumber) {
      const saved = state.perPage.get(pageNumber);
      state.pixelsPerMeter = (saved?.pixelsPerMeter && saved.pixelsPerMeter > 0) ? saved.pixelsPerMeter : 0;
      syncMeasureButton();

      if (!saved?.json) { updateTotal(); return; }

      canvas.getObjects().forEach(o => { if (o !== canvas.backgroundImage) canvas.remove(o); });

      canvas.loadFromJSON(saved.json, () => {
        if (state.mode !== MODES.PAN) canvas.forEachObject(o => o.selectable = false);
        canvas.requestRenderAll();
        updateTotal();
      });
    }

    // ===== OCR (cartouche) =====
    function preprocessToBW(srcCanvas) {
      const c = document.createElement("canvas");
      c.width = srcCanvas.width;
      c.height = srcCanvas.height;
      const ctx = c.getContext("2d");
      ctx.drawImage(srcCanvas, 0, 0);

      const img = ctx.getImageData(0, 0, c.width, c.height);
      const d = img.data;

      // grayscale + contrast + threshold
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        let v = (0.299*r + 0.587*g + 0.114*b);

        // contrast boost
        v = (v - 128) * 1.6 + 128;

        // threshold
        const bw = v > 160 ? 255 : 0;
        d[i] = d[i+1] = d[i+2] = bw;
      }
      ctx.putImageData(img, 0, 0);
      return c;
    }

    function parseScaleString(text) {
      const clean = String(text || "")
        .replace(/O/g, "0")
        .replace(/o/g, "0")
        .replace(/\s+/g, " ")
        .trim();

      const match = clean.match(CONFIG.SCALE_REGEX);
      if (!match?.[1]) return false;

      const scaleVal = parseInt(match[1], 10);

      // conversion ‚Äúpx par m‚Äù approxim√©e via DPI PDF (72dpi) * scale render
      // (On garde ton comportement actuel, car tu l‚Äôaimes bien üòâ)
      state.pixelsPerMeter = (72 * CONFIG.PDF_RENDER_SCALE * 39.3701) / scaleVal;

      Status.show(`‚úÖ √âchelle 1/${scaleVal} d√©tect√©e ! (page ${state.currentPage})`, "success");
      syncMeasureButton();
      setMode(MODES.MEASURE);
      saveMeasuresForPage(state.currentPage);
      return true;
    }

    async function performCartoucheOCR(pageCanvas) {
      Status.show("üëÅÔ∏è OCR √©chelle (cartouche)...", "normal");

      const bw = preprocessToBW(pageCanvas);

      for (const cropDef of CONFIG.OCR.crops) {
        const crop = document.createElement("canvas");
        const ctx = crop.getContext("2d");

        const sx = Math.floor(bw.width  * cropDef.x);
        const sy = Math.floor(bw.height * cropDef.y);
        const sw = Math.floor(bw.width  * cropDef.w);
        const sh = Math.floor(bw.height * cropDef.h);

        crop.width = sw;
        crop.height = sh;

        ctx.drawImage(bw, sx, sy, sw, sh, 0, 0, sw, sh);

        try {
          const result = await Tesseract.recognize(crop, CONFIG.OCR.lang);
          if (parseScaleString(result?.data?.text)) return true;
        } catch (e) {
          // on continue sur le crop suivant
        }
      }

      Status.show("‚ö†Ô∏è √âchelle non trouv√©e. √âtalonnage manuel possible.", "warning");
      return false;
    }

    // ===== Shapes + Arrows =====
    function makeLine(x1, y1, x2, y2, mode) {
      const zoom = canvas.getZoom();
      const stroke = (mode === MODES.SCALE ? CONFIG.SCALE_STROKE : (mode === MODES.MEASURE ? CONFIG.MEASURE_STROKE : CONFIG.PM_STROKE)) / zoom;
      const isScale = mode === MODES.SCALE;
      const color = (mode === MODES.MEASURE || mode === MODES.MINUTE) ? state.currentColor : "#ffffff";

      return new fabric.Line([x1, y1, x2, y2], {
        strokeWidth: stroke,
        stroke: isScale ? "#2c3e50" : color,
        strokeDashArray: isScale ? CONFIG.SCALE_DASH : null,
        originX: "center",
        originY: "center",
        selectable: false,
        evented: false
      });
    }

    function makeLabel(textValue, x, y) {
      const zoom = canvas.getZoom();
      return new fabric.Text(textValue, {
        fontSize: 14 / zoom,
        fill: "white",
        backgroundColor: "rgba(0,0,0,0.7)",
        left: x,
        top: y,
        originX: "center",
        originY: "bottom",
        fontFamily: "Segoe UI",
        selectable: false,
        evented: false
      });
    }

    function isTooSmall(distPx) {
      const zoom = canvas.getZoom();
      return distPx < (CONFIG.MIN_DRAW_PX_AT_ZOOM1 / zoom);
    }

    function createArrowHead(color) {
      const z = canvas.getZoom();
      return new fabric.Triangle({
        width: CONFIG.ARROW_W / z,
        height: CONFIG.ARROW_H / z,
        fill: color,
        stroke: color,
        strokeWidth: 0,
        originX: "center",
        originY: "center",
        selectable: false,
        evented: false
      });
    }

    function updateArrowsOutward(x1, y1, x2, y2) {
      if (!state.arrows) return;
      const angleDeg = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      state.arrows.a1.set({ left: x1, top: y1, angle: angleDeg + 270 });
      state.arrows.a2.set({ left: x2, top: y2, angle: angleDeg + 90  });
    }

    function wantArrowsNow() {
      return (state.mode === MODES.MEASURE) || (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE);
    }

    // ===== Finalize (touch OK) =====
    function finalizeScale(dep, arr) {
      const distPx = Math.hypot(arr.x - dep.x, arr.y - dep.y);
      if (isTooSmall(distPx)) { cancelTouchMeasure("Trop court"); return; }

      setTimeout(() => {
        const input = prompt("Distance r√©elle en M√àTRES ? (√©chelle page)", "1.0");
        const meters = parseFloat((input || "").replace(",", "."));
        if (!(meters > 0)) { cancelTouchMeasure("√âtalonnage annul√©"); return; }

        state.pixelsPerMeter = distPx / meters;
        Status.show(`‚úÖ √âtalonn√© (page ${state.currentPage}) : 1m = ${state.pixelsPerMeter.toFixed(2)} px`, "success");
        syncMeasureButton();

        saveMeasuresForPage(state.currentPage);
        cancelTouchMeasure();
        setMode(MODES.MEASURE);
      }, 50);
    }

    function finalizeMeasure(dep, arr) {
      if (!state.pixelsPerMeter) { cancelTouchMeasure("Pas d'√©chelle : √©talonne d'abord"); setMode(MODES.SCALE); return; }

      const distPx = Math.hypot(arr.x - dep.x, arr.y - dep.y);
      if (isTooSmall(distPx)) { cancelTouchMeasure("Trop court"); return; }

      const meters = distPx / state.pixelsPerMeter;
      const metersStr = `${meters.toFixed(2)} m`;

      const midX = (dep.x + arr.x) / 2;
      const midY = (dep.y + arr.y) / 2 - 15 / canvas.getZoom();
      const label = makeLabel(metersStr, midX, midY);

      const parts = [];
      if (state.line) parts.push(state.line);
      if (state.arrows) parts.push(state.arrows.a1, state.arrows.a2);

      // IMPORTANT: si jamais l‚Äôutilisateur n‚Äôa pas boug√© (rare), on cr√©e la ligne ici
      if (!state.line) {
        state.line = makeLine(dep.x, dep.y, arr.x, arr.y, state.mode);
        parts.unshift(state.line);
      }

      parts.forEach(obj => { if (obj) canvas.remove(obj); });

      const group = new fabric.Group([...parts, label], { selectable: true });
      group.forEachObject(obj => { obj.selectable = false; obj.evented = false; });
      group.isMeasure = true;
      group.measureValue = meters.toFixed(2);

      canvas.add(group);
      canvas.setActiveObject(group);

      updateTotal();
      canvas.requestRenderAll();
      saveMeasuresForPage(state.currentPage);

      cancelTouchMeasure();
      Status.show("Mesure ajout√©e", "success");
    }

    function finalizeMinuteCote(dep, arr) {
      const distPx = Math.hypot(arr.x - dep.x, arr.y - dep.y);
      if (isTooSmall(distPx)) { cancelTouchMeasure("Trop court"); return; }

      setTimeout(() => {
        const input = prompt("Cote terrain (m) ? (ex: 0.80)", "1.00");
        const meters = parseFloat((input || "").replace(",", "."));
        if (!(meters > 0)) { cancelTouchMeasure("Cote annul√©e"); return; }

        const metersStr = `${meters.toFixed(2)} m`;
        const midX = (dep.x + arr.x) / 2;
        const midY = (dep.y + arr.y) / 2 - 15 / canvas.getZoom();
        const label = makeLabel(metersStr, midX, midY);

        const parts = [];
        if (state.line) parts.push(state.line);
        if (state.arrows) parts.push(state.arrows.a1, state.arrows.a2);

        if (!state.line) {
          state.line = makeLine(dep.x, dep.y, arr.x, arr.y, state.mode);
          parts.unshift(state.line);
        }

        parts.forEach(obj => { if (obj) canvas.remove(obj); });

        const group = new fabric.Group([...parts, label], { selectable: true });
        group.forEachObject(obj => { obj.selectable = false; obj.evented = false; });
        group.isPm = true;
        group.pmKind = "COTE";
        group.pmValue = meters.toFixed(2);

        canvas.add(group);
        canvas.setActiveObject(group);

        canvas.requestRenderAll();
        saveMeasuresForPage(state.currentPage);

        cancelTouchMeasure();
        Status.show("Cote plan minute ajout√©e", "success");
      }, 50);
    }

    function finalizeTouchAction() {
      if (!state.dep || !state.arr) return;
      if (state.mode === MODES.SCALE) return finalizeScale(state.dep, state.arr);
      if (state.mode === MODES.MEASURE) return finalizeMeasure(state.dep, state.arr);
      if (state.mode === MODES.MINUTE && state.pmTool === PM_TOOLS.COTE) return finalizeMinuteCote(state.dep, state.arr);
    }

    // ===== Touch cursor driver =====
    function onTouchStart(e) {
      if (!isTouchMeasureMode()) return;
      if (e.touches.length !== 1) return;

      e.preventDefault();

      const t = e.touches[0];
      const cx = t.clientX;
      const cy = t.clientY - CONFIG.CURSOR_OFFSET_Y;

      setCursorUI(cx, cy, (state.step <= 1 ? "D√©part" : "Arriv√©e"));

      const w = clientToWrapper(cx, cy);
      state.cursorCanvas = wrapperPointToFabric(w.x, w.y);

      if (state.step === 0) {
        state.step = 1;
        showTapBar(true);
        setTapBarState(1);
        Status.show("Place le curseur sur le d√©part puis 'Valider d√©part'", "warning");
      }
    }

    function onTouchMove(e) {
      if (!isTouchMeasureMode()) return;
      if (e.touches.length !== 1) return;

      e.preventDefault();

      const t = e.touches[0];
      const cx = t.clientX;
      const cy = t.clientY - CONFIG.CURSOR_OFFSET_Y;

      setCursorUI(cx, cy, (state.step <= 1 ? "D√©part" : (state.step === 2 ? "Arriv√©e" : "OK")));

      const w = clientToWrapper(cx, cy);
      state.cursorCanvas = wrapperPointToFabric(w.x, w.y);

      // preview quand d√©part valid√©
      if (state.step === 2 && state.dep) {
        const dep = state.dep;
        const arr = state.cursorCanvas;

        if (!state.line) {
          state.line = makeLine(dep.x, dep.y, arr.x, arr.y, state.mode);
          canvas.add(state.line);

          if (wantArrowsNow()) {
            state.arrows = { a1: createArrowHead(state.currentColor), a2: createArrowHead(state.currentColor) };
            canvas.add(state.arrows.a1);
            canvas.add(state.arrows.a2);
          }
        }

        state.line.set({ x1: dep.x, y1: dep.y, x2: arr.x, y2: arr.y });
        if (state.arrows) updateArrowsOutward(dep.x, dep.y, arr.x, arr.y);
        canvas.requestRenderAll();
      }
    }

    ui.wrapper.addEventListener("touchstart", onTouchStart, { passive: false });
    ui.wrapper.addEventListener("touchmove", onTouchMove, { passive: false });

    ui.btnTapCancel.addEventListener("click", () => cancelTouchMeasure("Annul√©"));

    ui.btnTapStep.addEventListener("click", () => {
      if (!isTouchMeasureMode()) return;

      if (state.step === 1) {
        state.dep = { ...state.cursorCanvas };
        state.step = 2;
        setTapBarState(2);
        Status.show("Place le curseur sur l‚Äôarriv√©e puis 'Valider arriv√©e'", "warning");
        return;
      }

      if (state.step === 2) {
        state.arr = { ...state.cursorCanvas };
        state.step = 3;
        setTapBarState(3);

        // force une preview fig√©e
        const dep = state.dep;
        const arr = state.arr;

        if (!state.line) {
          state.line = makeLine(dep.x, dep.y, arr.x, arr.y, state.mode);
          canvas.add(state.line);
          if (wantArrowsNow()) {
            state.arrows = { a1: createArrowHead(state.currentColor), a2: createArrowHead(state.currentColor) };
            canvas.add(state.arrows.a1);
            canvas.add(state.arrows.a2);
          }
        }
        state.line.set({ x1: dep.x, y1: dep.y, x2: arr.x, y2: arr.y });
        if (state.arrows) updateArrowsOutward(dep.x, dep.y, arr.x, arr.y);
        canvas.requestRenderAll();

        Status.show("Appuie sur OK pour cr√©er la cote", "success");
      }
    });

    ui.btnTapOK.addEventListener("click", () => {
      if (state.step !== 3) return;
      finalizeTouchAction();
    });

    // ===== Desktop + Pan (inchang√©) =====
    function getClientPos(evt) {
      if (evt.touches && evt.touches.length > 0) return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
      return { x: evt.clientX, y: evt.clientY };
    }

    canvas.on("mouse:down", (o) => {
      const evt = o.e;
      const client = getClientPos(evt);

      if (IS_TOUCH && isTouchMeasureMode()) return;

      if (o.target && state.mode === MODES.PAN) return;

      if (state.mode === MODES.PAN) {
        state.isDragging = true;
        state.lastClientX = client.x;
        state.lastClientY = client.y;
        canvas.setCursor("grabbing");
        return;
      }
    });

    canvas.on("mouse:move", (o) => {
      const evt = o.e;
      const client = getClientPos(evt);

      if (IS_TOUCH && isTouchMeasureMode()) return;

      if (state.isDragging && state.mode === MODES.PAN) {
        const vpt = canvas.viewportTransform;
        vpt[4] += client.x - state.lastClientX;
        vpt[5] += client.y - state.lastClientY;
        state.lastClientX = client.x;
        state.lastClientY = client.y;
        clampViewportToBackground();
        canvas.requestRenderAll();
      }
    });

    canvas.on("mouse:up", () => {
      if (IS_TOUCH && isTouchMeasureMode()) return;

      if (state.mode === MODES.PAN && state.isDragging) {
        state.isDragging = false;
        canvas.setCursor("grab");
        clampViewportToBackground();
        canvas.requestRenderAll();
      }
    });

    // Delete / undo / clear / save
    ui.btn.del.addEventListener("click", () => {
      if (state.step !== 0) { cancelTouchMeasure("Annul√© (en cours)"); return; }
      const actives = canvas.getActiveObjects();
      if (!actives.length) return;
      actives.forEach(obj => canvas.remove(obj));
      canvas.discardActiveObject();
      updateTotal();
      canvas.requestRenderAll();
      Status.show("Supprim√©");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    ui.btn.undo.addEventListener("click", () => {
      if (state.step !== 0) { cancelTouchMeasure("Annul√© (en cours)"); return; }
      const objs = canvas.getObjects().filter(o => o !== canvas.backgroundImage);
      if (!objs.length) return;
      canvas.remove(objs[objs.length - 1]);
      updateTotal();
      canvas.requestRenderAll();
      Status.show("Annul√©");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    ui.btn.clear.addEventListener("click", () => {
      if (state.step !== 0) cancelTouchMeasure();
      if (!confirm("Tout effacer (page courante) ?")) return;
      canvas.getObjects().forEach(o => { if (o !== canvas.backgroundImage) canvas.remove(o); });
      canvas.discardActiveObject();
      updateTotal();
      canvas.requestRenderAll();
      Status.show("Page nettoy√©e");
      if (state.pdfDoc) saveMeasuresForPage(state.currentPage);
    });

    ui.btn.save.addEventListener("click", () => {
      if (state.step !== 0) cancelTouchMeasure();
      canvas.discardActiveObject();
      canvas.requestRenderAll();
      const dataURL = canvas.toDataURL({ format: "png", quality: 1, multiplier: CONFIG.EXPORT_MULTIPLIER });
      const a = document.createElement("a");
      a.download = `plan_page_${state.currentPage}.png`;
      a.href = dataURL;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    // File input
    ui.fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try { await loadPdfFile(file); }
      catch (err) { console.error(err); Status.show("Erreur chargement PDF.", "error"); }
      finally { ui.fileInput.value = ""; }
    });

    // Boot
    setDisabledAll(true);
    updatePagerUI();
    Status.show("Bienvenue");
    setMode(MODES.PAN);
    setPmTool(PM_TOOLS.COTE);
  </script>
</body>
</html>
